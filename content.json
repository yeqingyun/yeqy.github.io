{"meta":{"title":"一些","subtitle":"一些","description":null,"author":"叶青云","url":"http://ilovejava.cn"},"pages":[{"title":"","date":"2017-09-06T07:43:14.099Z","updated":"2017-09-06T07:43:14.099Z","comments":true,"path":"404.html","permalink":"http://ilovejava.cn/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"关于本站","date":"2016-01-10T01:12:45.000Z","updated":"2017-09-06T07:43:14.109Z","comments":false,"path":"about/index.html","permalink":"http://ilovejava.cn/about/index.html","excerpt":"","text":"在此声明，本站所有文章均属原创，都是自己的经验和总结，转载请注明出处。如文章有错误之处，请留言指出，非常感谢。打赏过的小伙伴今后将在此页列出。"},{"title":"分类","date":"2015-12-12T04:12:45.000Z","updated":"2017-09-06T07:43:14.110Z","comments":false,"path":"categories/index.html","permalink":"http://ilovejava.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-08-11T04:12:45.000Z","updated":"2017-09-06T07:43:14.121Z","comments":true,"path":"tags/index.html","permalink":"http://ilovejava.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Emacs之路","slug":"Emacs之路","date":"2017-05-07T09:03:13.000Z","updated":"2017-09-11T01:08:49.876Z","comments":true,"path":"posts/4a17a006/","link":"","permalink":"http://ilovejava.cn/posts/4a17a006/","excerpt":"介绍从今天开始使用Emacs了，本文只为记录我的学习过程，并不过多讲解Emacs。如果不认识Emacs，下面这段话会让你认识它。","text":"介绍从今天开始使用Emacs了，本文只为记录我的学习过程，并不过多讲解Emacs。如果不认识Emacs，下面这段话会让你认识它。 命令学习初期，这些命令都需要经常记忆，经常使用，不然容易忘记，那学习的时间可就浪费了。在这里，我按顺序记录下我学习到的命令，以便记忆。","categories":[],"tags":[{"name":"Activiti","slug":"Activiti","permalink":"http://ilovejava.cn/tags/Activiti/"}]},{"title":"用React重构俄罗斯方块，并升级为Plus版","slug":"用React重构俄罗斯方块，并升级为Plus版","date":"2017-01-10T05:36:43.000Z","updated":"2017-09-11T01:08:49.877Z","comments":true,"path":"posts/4a17a005/","link":"","permalink":"http://ilovejava.cn/posts/4a17a005/","excerpt":"之前已介绍过用原生js开发一个俄罗斯方块，如果没有看过的同学，可以点击这里","text":"之前已介绍过用原生js开发一个俄罗斯方块，如果没有看过的同学，可以点击这里 开发环境es7 + webpack + react 因为并不是特别复杂的应用也不是网络应用，所以没有用到其他的三方组件。源码用到部分es7语法和api，大部分是包括es6以前的语法和api。打包使用的是webpack，代码中只有开发环境的配置文件，因为本文重点不在webpack。如对打包要求比较严格的同学可自行配置生产环境的配置。 代码源码在我的github仓库中，有兴趣的同学可以看一看 在线演示俄罗斯方块 源码分析这里也只是挑重点讲，不会解释es7、es6语法。 containers/index.js游戏逻辑操作基本都写在这个组件中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268import React, &#123; Component &#125; from \"react\"import Info from \"../components/info\"import Game from \"../components/game\"import * as squareUtil from \"../util/squareUtil\"import * as operate from \"../util/operate\"import \"../static/css/style.css\"let cur = squareUtil.randmonSquare()let timer = nulllet pauseFlag = truelet timeCount = 0export default class App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; gameData: squareUtil.gamedata, next: squareUtil.randmonSquare(), score: 0, showTime: 0 &#125; &#125; //判断点是否合法 checkPonit = (pox, x, y) =&gt; &#123; try &#123; let data = this.state.gameData[pox.x + x][pox.y + y] if (pox.x + x &lt; 0) &#123; return false &#125; else if (pox.x + x &gt;= this.state.gameData.length) &#123; return false &#125; else if (pox.y + y &lt; 0) &#123; return false &#125; else if (pox.y + y &gt;= this.state.gameData[0].length) &#123; return false &#125; else if (data != 'none' &amp;&amp; data.indexOf(1) &lt; 0) &#123; return false &#125; return true &#125; catch (e) &#123; return false &#125; &#125; //判断方块位置是否合法 checkLegal = (pos, data) =&gt; &#123; for (let i = 0; i &lt; data.length; i++) &#123; for (let j = 0; j &lt; data[0].length; j++) &#123; if (data[i][j] != 'none') &#123; if (!this.checkPonit(pos, i, j)) &#123; return false &#125; &#125; &#125; &#125; return true &#125; //判断游戏是否结束 checkGameOver = () =&gt; &#123; let &#123; gameData, next &#125; = this.state if (!this.checkLegal(next.origin, next.data)) &#123; return true &#125; return false &#125; //判断消行 checkClear = () =&gt; &#123; let &#123; gameData &#125; = this.state let lines = 0 let check = (data) =&gt; &#123; return data != 'none' &#125; for (let i = gameData.length - 1; i &gt;= 0; i--) &#123; let flag = gameData[i].every(check) if (flag) &#123; lines++ for (let k = i; k &gt;= 1; k--) &#123; gameData[k] = gameData[k - 1] &#125; gameData[0] = squareUtil.initLineData.splice(0) i++ &#125; &#125; this.setState(&#123; gameData &#125;) return lines &#125; down = () =&gt; &#123; if (cur.canDown(this.checkLegal)) &#123; this.squareGO(cur.down) return true &#125; else &#123; return false &#125; &#125; left = () =&gt; &#123; if (cur.canLeft(this.checkLegal)) this.squareGO(cur.left) &#125; right = () =&gt; &#123; if (cur.canRight(this.checkLegal)) this.squareGO(cur.right) &#125; rotate = () =&gt; &#123; if (cur.canRotate(this.checkLegal)) this.squareGO(cur.rotate) &#125; fall = () =&gt; &#123; while (this.down()) &#123; &#125; &#125; pause = () =&gt; &#123; if ((pauseFlag = !pauseFlag, !pauseFlag)) &#123;//暂停 this.stop() operate.clearKeyEvenet(this) &#125; else &#123;//继续 operate.bindKeyEvenet(this) timer = setInterval(this.move, 210) &#125; &#125; //初始化第一个方块及绑定键盘监听 init = () =&gt; &#123; operate.bindKeyEvenet(this) let &#123; gameData &#125; = this.state let &#123; origin, data &#125; = cur for (let i = 0; i &lt; data.length; i++) &#123; for (let j = 0; j &lt; data[0].length; j++) &#123; if (data[i][j] != 'none') gameData[i + origin.x][j + origin.y] = data[i][j] + \"1\" &#125; &#125; this.setState(&#123; gameData &#125;) &#125; //将cur设置到gameData显示出来 setData = () =&gt; &#123; let &#123; gameData &#125; = this.state let &#123; origin, data &#125; = cur for (let i = 0; i &lt; data.length; i++) &#123; for (let j = 0; j &lt; data[0].length; j++) &#123; if (this.checkPonit(origin, i, j)) if (data[i][j] != 'none') gameData[i + origin.x][j + origin.y] = data[i][j] + '1' &#125; &#125; this.setState(&#123; gameData &#125;) &#125; //清空cur下移之前的显示 clearData = () =&gt; &#123; let &#123; gameData &#125; = this.state let &#123; origin, data &#125; = cur for (let i = 0; i &lt; data.length; i++) &#123; for (let j = 0; j &lt; data[0].length; j++) &#123; if (this.checkPonit(origin, i, j)) gameData[i + origin.x][j + origin.y] = 'none' &#125; &#125; this.setState(&#123; gameData &#125;) &#125; //方块方法 squareGO = (fun) =&gt; &#123; this.clearData() cur::fun() this.setData() &#125; //自动下落 move = () =&gt; &#123; timeCount++ squareUtil.addTime(timeCount, (showTime) =&gt; &#123; this.setState(&#123; showTime: showTime &#125;) &#125;) if (cur.canDown(this.checkLegal)) &#123; this.squareGO(cur.down) &#125; else &#123; if (this.checkGameOver()) &#123; this.nextSquare() this.setData() this.stop() alert(\"game over, your score is \" + this.state.score)//结束动画 &#125; else &#123; this.fixed() let lines = this.checkClear() if (lines) &#123;//如果消除行数 let score = this.state.score + squareUtil.getScore(lines) this.setState(&#123; score &#125;) &#125; this.nextSquare() &#125; &#125; &#125; //方块固定 fixed = () =&gt; &#123; let &#123; gameData &#125; = this.state let &#123; origin, data &#125; = cur for (let i = 0; i &lt; data.length; i++) &#123; for (let j = 0; j &lt; data[0].length; j++) &#123; if (this.checkPonit(origin, i, j)) gameData[i + origin.x][j + origin.y] = data[i][j] &#125; &#125; this.setState(&#123; gameData &#125;) &#125; //停止游戏 stop = () =&gt; &#123; if (timer) clearInterval(timer) &#125; //下一个方块 nextSquare() &#123; let &#123; next &#125; = this.state cur = next this.setState(&#123; next: squareUtil.randmonSquare() &#125;) &#125; //初始化，开始自动下落 componentDidMount() &#123; this.init() timer = setInterval(this.move, 210) &#125; render() &#123; let &#123; score, showTime, next, gameData &#125; = this.state return ( &lt;div&gt; &lt;Game next=&#123;next&#125; gameData=&#123;gameData&#125; /&gt; &lt;Info score=&#123;score&#125; showTime=&#123;showTime&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 这个组件将游戏数据保存在state，当数据变化时，设置到state中触发components中木偶组件的重新渲染。 components下的木偶组件此目录下均为木偶组件，负责展示数据，不参与逻辑操作，所以都定义为无状态组件。 game.js负责展示放方块的组件12345678910111213141516171819202122232425262728import React from \"react\"import GameOver from \"./gameOver\"export default (&#123; gameData, next &#125;) =&gt;&lt;div&gt; &lt;div id=\"local_game\" className=\"game\"&gt; &#123; gameData.map((arrayItem) =&gt; arrayItem.map((item) =&gt; &lt;div className=&#123;item ? item.replace(\"1\", \"\") : \"none\"&#125;&gt;&lt;/div&gt; ) ) &#125; &lt;/div&gt; &lt;GameOver /&gt; &lt;div id=\"local_next\" className=\"next\"&gt; &#123; next &amp;&amp; next.data.length ? next.data.map((arrayItem) =&gt; arrayItem.map((item) =&gt; &lt;div className=&#123;item ? item : \"none\"&#125;&gt;&lt;/div&gt; ) ) : null &#125; &lt;/div&gt;&lt;/div&gt; info.js负责展示时间，分数，操作介绍的组件 1234567891011121314import React, &#123; Component &#125; from \"react\"import Introduce from \"./introduce\"import TimePanel from \"./timePanel\"import ScorePanel from \"./scorePanel\"export default (&#123; score, showTime &#125;) =&gt; &lt;div className=\"info\"&gt; &lt;TimePanel showTime = &#123;showTime&#125; /&gt; &lt;ScorePanel score = &#123;score&#125; /&gt; &lt;Introduce /&gt; &lt;/div&gt; 总体概述嘛，逻辑很简单，方块定义和生成方块仍然沿用上个版本的代码，contianer/index.js我们称他为app,app控制游戏数据，game组件显示方块,info组件显示信息。我自认为注释我的注释写的还算善解人意，想了解的同学姑且一看吧。对比react开发和用原生js开发中，我最大的感受就是react开发起来更加方便，不用关心重新渲染的细节以及更加准确的控制事件触发状态，当然，react的中心思想是组件化，如果有已存在的组件可以大大加快开发效率（但是这里我没有用到第三方组件）。es7的一些语法和api也让我省去了写一些在es5中比较麻烦的写法。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://ilovejava.cn/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://ilovejava.cn/tags/javascript/"},{"name":"游戏","slug":"游戏","permalink":"http://ilovejava.cn/tags/游戏/"}]},{"title":"深入浅出javascript(一)","slug":"深入浅出javascript(一)","date":"2016-05-09T06:56:43.000Z","updated":"2017-09-06T07:43:14.106Z","comments":true,"path":"posts/172175ba/","link":"","permalink":"http://ilovejava.cn/posts/172175ba/","excerpt":"简介此文章适合有一定javascript基础的同学用来巩固和深入javascript知识的文章。","text":"简介此文章适合有一定javascript基础的同学用来巩固和深入javascript知识的文章。 六种数据类型javascript中有六种数据类型 number string boolean null undefined Object 因为js中定义变量不需要指定类型，所以数据在一些操作符和运算符之间存在着隐式转换，例如：1234var a = 11; console.log(a + \"22\")//结果是1122 变量a被隐式转换为字符串console.log(a - '10')//结果是1 字符10被隐式转换为数字console.log(a - true)//结果是10 布尔值true被隐式转换为数字1 正因为存在这些隐式转换的逻辑，我们可以利用它巧妙的进行类型转换，数字转字符只要加上一个空字符串，字符转数字只要减去0等等方法。在进行判断操作时同样存在着隐式转换，例如：1234if(1 == \"1\") console.log(\" 1 = '1'\")//结果是true，会输出1 = '1'if(false == 0 ) console.log(\" false = 0 \")//结果是true，会输出false = 0 但有些时候我们希望1等于”1”是false，这个时候我们就需要用到 ===，===在==的基础之上添加了类型判断，即判断值之前首先会判断左右两边的类型，如果不同则直接返回false，类型相同才会去判断值。这里值得一提的是六种数据类型中的Object用 === 和==判断时，判断用到的值是该对象存储的内存地址（所以判断Object的值一般不使用这两个，判断方法后面会说道）。 javascript中还存在着一些包装类型，包装类型并不是一种类型，可以把它理解为基础类型的包装，number类型的包装类型是Number，string类型的包装类型是String，boolean类型的包装类型是Boolean。在对基础类型进行对象操作时，js会自动创建一个相应包装类型对象供你操作，当操作结束后，该对象将会销毁（代码如下）。为什么存在包装类型呢？是为了给基础类型提供更加便捷的操作，普通类型可以直接调用包装类型中的方法，不觉得很方便吗？ 12345var a = \"abc\"console.log(a.length)//创建一个String对象a.id = 1console.log(a.id)//undefined 因为包装类型已经销毁console.log((123).toString())// \"123\" 类型检测js中检测类型的方法有多种，如下 typeof instanceof Object.prototype.toString constructor duck type typeof运算符判断类型的用法是typeof 100，typeof后面接着数据这种的用法，返回结果是字符串，数字返回’number’，布尔返回’boolean’，undefined返回的是’undefined’，function和Objct返回’function’…这里就不一一列举了，同学们可以到控制台尝试一下。这里需要注意的是typeof [0,1]返回的是Object,typeof NaN 返回的是’number’，typeof null 返回的是’object’，所以在使用typeof检测数组,NaN和null时要特别注意。 instanceof是一个基于原型链判断类型的操作符，如果不了解原型链的同学，这里可以不必强行理解，只要记住这个概念就行了，后面的文章会仔细介绍原型链。instanceOf用来检测对象的类型，如obj instanceof Object，若obj是基本类型，则会直接返回false，若Object不是函数或者函数构造器，则会抛出一个TypeError异常。instaceof检测的过程是先判断obj.__proto__(__proto__是在chrome浏览器暴露出来的一个属性，用以描述对象的原型，也可以使用Object.getPrototypeOf)是否等于Object.prototype,如果相等，则返回true，如果不等则继续向上查找，obj.__proto__.__proto__是否等于Object.prototype，以此类推，直到找到相等的，返回true，若寻找完整条原型链都不想等，则返回false。 Object.prototype.toString.apply(obj)既可以判断基础类型，也可以判断对象类型。判断的返回值是字符串，数组类型返回’[object Array]’，数字类型返回’[object Number]’，函数类型返回’[object Function]’，其他的同学们可以去尝试一下。这里值得注意的是用此方法判断undefined会返回’[object Undefined]’，判断null会返回’[object Null]’，而在IE6/7/8下，判断null则是返回’[object Object]’。 constructor是用来检测对象类型的，通过对象__proto__属性上的constructor判断，注意constructor是可以修改的，所以此方式检测的结果不一定正确，可结合其他检测方式来保证结果正确性，示例如下： 12var a = new Number(1);a.constructor == Number?console.log(\"a是Number类型\"):console.log(\"a不是Number类型\")//结果输出是a是Number类型 duck type –“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 通过检测对象是否具体的属性来判断其类型，当然存在着很大的风险（恰巧拥有同样的属性），如Object的isArray方法： isArray: function(object) { return object != null &amp;&amp; typeof object == \"object\" &amp;&amp; 'splice' in object &amp;&amp; 'join' in object; } 综上所述，在判断数据类型时应该按照需求选用方法，如基本类型和function使用typeof，自定义对象和原生对对象使用instanceof，原生对象和iframe之间的对象类型使用Object.prototype.toString，null和undefined用===判断等等… 未完待续…","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ilovejava.cn/tags/javascript/"}]},{"title":"Activiti回顾","slug":"Activiti回顾","date":"2016-03-07T09:03:13.000Z","updated":"2017-09-06T08:00:24.353Z","comments":true,"path":"posts/4a17a004/","link":"","permalink":"http://ilovejava.cn/posts/4a17a004/","excerpt":"由于一段时间没弄Activiti了，有一些生疏，不能让曾经熟悉的东西偷偷溜走，故写一篇Activiti回顾来记录Activiti知识点和遇到的问题以此来留住它。 这里暂时不提到bpmn的模型(如：启动结束事件、顺序流、网关，监听器，子流程等)，以后有时间再补上。","text":"由于一段时间没弄Activiti了，有一些生疏，不能让曾经熟悉的东西偷偷溜走，故写一篇Activiti回顾来记录Activiti知识点和遇到的问题以此来留住它。 这里暂时不提到bpmn的模型(如：启动结束事件、顺序流、网关，监听器，子流程等)，以后有时间再补上。 以下代码均乃项目实际用到的代码，Activiti version 为 5.1.3，请配合注释食用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798 //根据配置创建流程引擎 ProcessEngine processEngine = ProcessEngineConfiguration .createProcessEngineConfigurationFromResource(\"activiti.cfg.xml\"); FormService formService = processEngine.getFormService(); TaskService taskService = processEngine.getTaskService(); RepositoryService repositoryService = processEngine.getRepositoryService();//流程部署相关Serivce RuntimeService runtimeService = processEngine.getRuntimeService();//运行变量相关Service HistoryService historyService = processEngine.getHistoryService(); IdentityService identityService = processEngine.getHistoryService();//身份认证Service ManagementService managementService = processEngine.getManagementService();//流程管理维护及执行命令Service //部署流程 Deployment deployment = repositoryService .createDeployment()//创建一个部署对象 .name(\"leave\")//添加部署的名称 .addZipInputStream(new ZipInputStream(new ClassPathResource(\"leave.bar\").getInputStream())); //.addClasspathResource(\"diagrams/leave.bpmn\")//从classpath的资源中加载，一次只能加载一个文件 //.addClasspathResource(\"diagrams/leave.png\")//从classpath的资源中加载，一次只能加载一个文件 //第二个参数为true时表示级联删除流程实例、历史记录和任务。也可以通过deleteDeploymentCascade（deploymentId）来级联删除。 //repositoryService.deleteDeployment(deploymentId, true); //发起流程 //启动流程带表单数据 processDefinitionId：流程定义id，如：L-leave:1:5 ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinitionId, formProperties); //processDefinitionKey：流程定义关键字，如:L-leave //ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(processDefinitionKey, formProperties); //businessKey用来关联业务数据，以此来将业务和流程解耦 //ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinitionId, businessKey, formProperties); //按照流程定义id查询所有该流程实例 //根据processDefinitionId和偏移量查询某流程的流程实例集 List&lt;ProcessInstance&gt; processInstances = runtimeService.createProcessInstanceQuery() .orderByDeploymentId().desc().processDefinitionId(processDefinitionId).listPage(offset, limit); //查询待办任务 //按用户查询待办任务 List&lt;Task&gt; personalTasks = taskService() .createTaskQuery() .taskAssignee(assignee)//指定个人任务查询，指定办理人 .active().orderByTaskId().desc() .orderByTaskCreateTime().desc() .listPage(offset, limit); //按用户组查询待办任务 List&lt;Task&gt; candidateUserTasks = taskService() .createTaskQuery() .taskCandidateUser(candidateUser)//指定用户组任务 .active().orderByTaskId().desc() .orderByTaskCreateTime().desc() .listPage(offset, limit); //合并以上两个=所有待办任务 tasks.addAll(personalTasks); tasks.addAll(candidateUserTasks); //获取流程关联业务数据 ProcessInstance processInstance = runtimeService.createProcessInstanceQuery() .processInstanceId(processInstanceId).active().singleResult(); String leaveId = processInstance.getBusinessKey(); //获取到业务实体数据 query操作 leaveService.get(leaveId); //签收以及处理任务 //签收任务 taskService.claim(taskId, userId); //保存附件 Attachment attachment = taskService.createAttachment(null, taskId, processInstanceId, fileName, fileNo, fileDownLoadUrl + sb);taskService.saveAttachment(attachment); //处理任务带表单数据 taskService.complete(taskId, formProperties); //获取流程表单 //\"freeMark\"是流程引擎配置中定义的表单引擎，后面给出代码 //获取开始表单 formService.getRenderedStartForm(processDefinition.getId(),\"freemarker\") //获取任务表单 formService.getRenderedTaskForm(task.getId(), \"freemarker\"); //获得历史表单+当前任务的表单，当用户办理任务时，想要看历史表单 //result就是历史表单数据，GetRenderedTaskHistoryFormCmd，GetRenderedTaskHistoryFormCmd代码在下面贴出 Object reuslt = managementService.executeCommand( new GetRenderedTaskHistoryFormCmd(processInstanceId, \"freemarker\")); //获取历史变量 List&lt;HistoricVariableInstance&gt; list = historyService.createHistoricVariableInstanceQuery().processInstanceId(task.getProcessInstanceId()).list() if (activitiInstance.getActivityType().equals(\"startEvent\")) &#123;//获取开始表单的附件 List&lt;Attachment&gt; attachmentList = taskService .getProcessInstanceAttachments(processInstanceId); &#125; else &#123;//获取任务表单的附件 List&lt;Attachment&gt; attachmentList = taskService .getTaskAttachments(activitiInstance.getTaskId()); &#125; //根据processInstId删除ACT_HI_VARINST Context.getCommandContext().getHistoricVariableInstanceEntityManager() .deleteHistoricVariableInstanceByProcessInstanceId(processInstId); //删除ACT_HI_TASKINST Context.getCommandContext().getHistoricTaskInstanceEntityManager() .deleteHistoricTaskInstancesByProcessInstanceId(processInstId); //删除ACT_HI_DETAIL Context.getCommandContext().getHistoricDetailEntityManager() .deleteHistoricDetailsByProcessInstanceId(processInstId); //获取流程的下一步处理者 List&lt;Task&gt; taskList = taskService.createTaskQuery().processInstanceId(procInstId).active().list(); if (!CollectionUtils.isEmpty(taskList)) &#123; //普通任务 if (taskList.size() == 1) &#123; Task nextTask = taskList.get(0); if (StringUtils.isEmpty(nextTask.getAssignee())) &#123;//指定用户组 Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); params.put(\"type\", \"candidate\"); params.put(\"procInstId\", nextTask.getProcessInstanceId()); activitiHelpDao.queryTaskCandidates(params); /** * SELECT DISTINCT I.*,u.name as USER_NAME_ * FROM * ACT_RU_TASK RES * INNER JOIN ACT_RU_IDENTITYLINK I ON I.TASK_ID_ = RES.ID_ * INNER JOIN auth_user u on I.USER_ID_ = u.account * WHERE RES.ASSIGNEE_ IS NULL AND I.TYPE_ = #&#123;type&#125; * AND RES.PROC_INST_ID_ = #&#123;procInstId&#125; */ &#125; &#125; else &#123;//指定用户 User nextUser = userDao.getByAccount(nextTask.getAssignee()); &#125; &#125; else &#123;//并发任务 //暂时不写,后续补上... &#125; //通过processDefinitionId获取流程图 ProcessDefinitionEntity definition = new GetDeploymentProcessDefinitionCmd( processDefinitionId).execute(commandContext); String diagramResourceName = definition.getDiagramResourceName(); String deploymentId = definition.getDeploymentId(); byte[] bytes = commandContext.getResourceEntityManager() .findResourceByDeploymentIdAndResourceName(deploymentId, diagramResourceName).getBytes(); InputStream is = new ByteArrayInputStream(bytes);&#125; /** * 流程图绘制工具 */ public class CustomProcessDiagramGenerator &#123; public static final int OFFSET_SUBPROCESS = 5; public static final int OFFSET_TASK = 20; private static List&lt;String&gt; taskType = new ArrayList&lt;String&gt;(); private static List&lt;String&gt; eventType = new ArrayList&lt;String&gt;(); private static List&lt;String&gt; gatewayType = new ArrayList&lt;String&gt;(); private static List&lt;String&gt; subProcessType = new ArrayList&lt;String&gt;(); private static List&lt;String&gt; boundaryType = Arrays.asList(new String[]&#123;\"boundaryTimer\",\"boundaryMessage\",\"boundarySignal\"&#125;); private static Color RUNNING_COLOR = Color.RED; private static Color HISTORY_COLOR = Color.GREEN; private static Color SKIP_COLOR = Color.GRAY; private static Stroke THICK_BORDER_STROKE = new BasicStroke(3.0f); private int minX; private int minY; public CustomProcessDiagramGenerator() &#123; init(); &#125; protected static void init() &#123; taskType.add(BpmnXMLConstants.ELEMENT_TASK_MANUAL); taskType.add(BpmnXMLConstants.ELEMENT_TASK_RECEIVE); taskType.add(BpmnXMLConstants.ELEMENT_TASK_SCRIPT); taskType.add(BpmnXMLConstants.ELEMENT_TASK_SEND); taskType.add(BpmnXMLConstants.ELEMENT_TASK_SERVICE); taskType.add(BpmnXMLConstants.ELEMENT_TASK_USER); gatewayType.add(BpmnXMLConstants.ELEMENT_GATEWAY_EXCLUSIVE); gatewayType.add(BpmnXMLConstants.ELEMENT_GATEWAY_INCLUSIVE); gatewayType.add(BpmnXMLConstants.ELEMENT_GATEWAY_EVENT); gatewayType.add(BpmnXMLConstants.ELEMENT_GATEWAY_PARALLEL); eventType.add(\"intermediateTimer\"); eventType.add(\"intermediateMessageCatch\"); eventType.add(\"intermediateSignalCatch\"); eventType.add(\"intermediateSignalThrow\"); eventType.add(\"messageStartEvent\"); eventType.add(\"startTimerEvent\"); eventType.add(BpmnXMLConstants.ELEMENT_ERROR); eventType.add(BpmnXMLConstants.ELEMENT_EVENT_START); eventType.add(\"errorEndEvent\"); eventType.add(BpmnXMLConstants.ELEMENT_EVENT_END); //add eventType.add(\"boundaryTimer\"); eventType.add(\"boundaryMessage\"); eventType.add(\"boundarySignal\"); subProcessType.add(BpmnXMLConstants.ELEMENT_SUBPROCESS); subProcessType.add(BpmnXMLConstants.ELEMENT_CALL_ACTIVITY); &#125; public InputStream generateDiagram(String processInstanceId) throws IOException &#123; HistoricProcessInstance historicProcessInstance = Context .getCommandContext().getHistoricProcessInstanceEntityManager() .findHistoricProcessInstance(processInstanceId); String processDefinitionId = historicProcessInstance .getProcessDefinitionId(); // //注释了下面的代码，防止流程图和xml一起部署，坐标偏移的问题 // GetBpmnModelCmd getBpmnModelCmd = new GetBpmnModelCmd( // processDefinitionId); // BpmnModel bpmnModel = getBpmnModelCmd.execute(Context // .getCommandContext()); // // Point point = getMinXAndMinY(bpmnModel); // this.minX = point.x; // this.minY = point.y; // this.minX = (this.minX &lt;= 5) ? 5 : this.minX; // this.minY = (this.minY &lt;= 5) ? 5 : this.minY; // this.minX -= 5; // this.minY -= 5; ProcessDefinitionEntity definition = new GetDeploymentProcessDefinitionCmd( processDefinitionId).execute(Context.getCommandContext()); String diagramResourceName = definition.getDiagramResourceName(); String deploymentId = definition.getDeploymentId(); byte[] bytes = Context .getCommandContext() .getResourceEntityManager() .findResourceByDeploymentIdAndResourceName(deploymentId, diagramResourceName).getBytes(); InputStream originDiagram = new ByteArrayInputStream(bytes); BufferedImage image = ImageIO.read(originDiagram); HistoricActivityInstanceQueryImpl historicActivityInstanceQueryImpl = new HistoricActivityInstanceQueryImpl(); historicActivityInstanceQueryImpl.processInstanceId(processInstanceId) .orderByHistoricActivityInstanceStartTime().asc(); //绘画连接线 this.drawHistoryFlow(image, processInstanceId); // Page page = new Page(0, 100); // List&lt;HistoricActivityInstance&gt; activityInstances = Context // .getCommandContext() // .getHistoricActivityInstanceEntityManager() // .findHistoricActivityInstancesByQueryCriteria( // historicActivityInstanceQueryImpl, page); //update by lipw 2014-10-30 //开启新事务，查询最新的数据 ActivitiHelpService activitiHelpService = (ActivitiHelpService)SpringTools.getBean(ActivitiHelpService.class); List&lt;HistoricActivityInstance&gt; activityInstances = activitiHelpService.queryHisActInst4NewTransaction(processInstanceId); //update by lipw end for (HistoricActivityInstance historicActivityInstance : activityInstances) &#123; String historicActivityId = historicActivityInstance .getActivityId(); ActivityImpl activity = definition.findActivity(historicActivityId); if (activity != null) &#123; if (historicActivityInstance.getEndTime() == null) &#123; // 节点正在运行中 signRunningNode(image, activity.getX() - this.minX, activity.getY() - this.minY, activity.getWidth(), activity.getHeight(), historicActivityInstance.getActivityType()); &#125; else &#123; String deleteReason = null; if (historicActivityInstance.getTaskId() != null) &#123; deleteReason = Context .getCommandContext() .getHistoricTaskInstanceEntityManager() .findHistoricTaskInstanceById( historicActivityInstance.getTaskId()) .getDeleteReason(); &#125; // 节点已经结束 if (\"跳过\".equals(deleteReason)) &#123; signSkipNode(image, activity.getX() - this.minX, activity.getY() - this.minY, activity.getWidth(), activity.getHeight(), historicActivityInstance.getActivityType()); &#125; else &#123; signHistoryNode(image, activity.getX() - this.minX, activity.getY() - this.minY, activity.getWidth(), activity.getHeight(), historicActivityInstance.getActivityType()); &#125; &#125; &#125; &#125; ByteArrayOutputStream out = new ByteArrayOutputStream(); String formatName = getDiagramExtension(diagramResourceName); ImageIO.write(image, formatName, out); return new ByteArrayInputStream(out.toByteArray()); &#125; private static String getDiagramExtension(String diagramResourceName) &#123; return FilenameUtils.getExtension(diagramResourceName); &#125; /** * 标记运行节点 * * @param image * 原始图片 * @param x * 左上角节点坐在X位置 * @param y * 左上角节点坐在Y位置 * @param width * 宽 * @param height * 高 * @param activityType * 节点类型 */ private static void signRunningNode(BufferedImage image, int x, int y, int width, int height, String activityType) &#123; Color nodeColor = RUNNING_COLOR; Graphics2D graphics = image.createGraphics(); try &#123; drawNodeBorder(x, y, width, height, graphics, nodeColor, activityType); &#125; finally &#123; graphics.dispose(); &#125; &#125; /** * 标记历史节点 * * @param image * 原始图片 * @param x * 左上角节点坐在X位置 * @param y * 左上角节点坐在Y位置 * @param width * 宽 * @param height * 高 * @param activityType * 节点类型 */ private static void signHistoryNode(BufferedImage image, int x, int y, int width, int height, String activityType) &#123; Color nodeColor = HISTORY_COLOR; Graphics2D graphics = image.createGraphics(); try &#123; drawNodeBorder(x, y, width, height, graphics, nodeColor, activityType); &#125; finally &#123; graphics.dispose(); &#125; &#125; private static void signSkipNode(BufferedImage image, int x, int y, int width, int height, String activityType) &#123; Color nodeColor = SKIP_COLOR; Graphics2D graphics = image.createGraphics(); try &#123; drawNodeBorder(x, y, width, height, graphics, nodeColor, activityType); &#125; finally &#123; graphics.dispose(); &#125; &#125; /** * 绘制节点边框 * * @param x * 左上角节点坐在X位置 * @param y * 左上角节点坐在Y位置 * @param width * 宽 * @param height * 高 * @param graphics * 绘图对象 * @param color * 节点边框颜色 * @param activityType * 节点类型 */ protected static void drawNodeBorder(int x, int y, int width, int height, Graphics2D graphics, Color color, String activityType) &#123; graphics.setPaint(color); graphics.setStroke(THICK_BORDER_STROKE); if (taskType.contains(activityType)) &#123; drawTask(x, y, width, height, graphics); &#125; else if (gatewayType.contains(activityType)) &#123; drawGateway(x, y, width, height, graphics); &#125; else if (eventType.contains(activityType)) &#123; drawEvent(x, y, width, height, graphics); &#125; else if (subProcessType.contains(activityType)) &#123; drawSubProcess(x, y, width, height, graphics); &#125; &#125; /** * 绘制任务 */ protected static void drawTask(int x, int y, int width, int height, Graphics2D graphics) &#123; RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, OFFSET_TASK, OFFSET_TASK); graphics.draw(rect); &#125; /** * 绘制网关 */ protected static void drawGateway(int x, int y, int width, int height, Graphics2D graphics) &#123; Polygon rhombus = new Polygon(); rhombus.addPoint(x, y + (height / 2)); rhombus.addPoint(x + (width / 2), y + height); rhombus.addPoint(x + width, y + (height / 2)); rhombus.addPoint(x + (width / 2), y); graphics.draw(rhombus); &#125; /** * 绘制任务 */ protected static void drawEvent(int x, int y, int width, int height, Graphics2D graphics) &#123; Double circle = new Ellipse2D.Double(x, y, width, height); graphics.draw(circle); &#125; /** * 绘制子流程 */ protected static void drawSubProcess(int x, int y, int width, int height, Graphics2D graphics) &#123; RoundRectangle2D rect = new RoundRectangle2D.Double(x + 1, y + 1, width - 2, height - 2, OFFSET_SUBPROCESS, OFFSET_SUBPROCESS); graphics.draw(rect); &#125; protected Point getMinXAndMinY(BpmnModel bpmnModel) &#123; // We need to calculate maximum values to know how big the image will be in its entirety double theMinX = java.lang.Double.MAX_VALUE; double theMaxX = 0; double theMinY = java.lang.Double.MAX_VALUE; double theMaxY = 0; for (Pool pool : bpmnModel.getPools()) &#123; GraphicInfo graphicInfo = bpmnModel.getGraphicInfo(pool.getId()); theMinX = graphicInfo.getX(); theMaxX = graphicInfo.getX() + graphicInfo.getWidth(); theMinY = graphicInfo.getY(); theMaxY = graphicInfo.getY() + graphicInfo.getHeight(); &#125; List&lt;FlowNode&gt; flowNodes = gatherAllFlowNodes(bpmnModel); for (FlowNode flowNode : flowNodes) &#123; GraphicInfo flowNodeGraphicInfo = bpmnModel.getGraphicInfo(flowNode .getId()); // width if ((flowNodeGraphicInfo.getX() + flowNodeGraphicInfo.getWidth()) &gt; theMaxX) &#123; theMaxX = flowNodeGraphicInfo.getX() + flowNodeGraphicInfo.getWidth(); &#125; if (flowNodeGraphicInfo.getX() &lt; theMinX) &#123; theMinX = flowNodeGraphicInfo.getX(); &#125; // height if ((flowNodeGraphicInfo.getY() + flowNodeGraphicInfo.getHeight()) &gt; theMaxY) &#123; theMaxY = flowNodeGraphicInfo.getY() + flowNodeGraphicInfo.getHeight(); &#125; if (flowNodeGraphicInfo.getY() &lt; theMinY) &#123; theMinY = flowNodeGraphicInfo.getY(); &#125; for (SequenceFlow sequenceFlow : flowNode.getOutgoingFlows()) &#123; List&lt;GraphicInfo&gt; graphicInfoList = bpmnModel .getFlowLocationGraphicInfo(sequenceFlow.getId()); for (GraphicInfo graphicInfo : graphicInfoList) &#123; // width if (graphicInfo.getX() &gt; theMaxX) &#123; theMaxX = graphicInfo.getX(); &#125; if (graphicInfo.getX() &lt; theMinX) &#123; theMinX = graphicInfo.getX(); &#125; // height if (graphicInfo.getY() &gt; theMaxY) &#123; theMaxY = graphicInfo.getY(); &#125; if (graphicInfo.getY() &lt; theMinY) &#123; theMinY = graphicInfo.getY(); &#125; &#125; &#125; &#125; List&lt;Artifact&gt; artifacts = gatherAllArtifacts(bpmnModel); for (Artifact artifact : artifacts) &#123; GraphicInfo artifactGraphicInfo = bpmnModel.getGraphicInfo(artifact .getId()); if (artifactGraphicInfo != null) &#123; // width if ((artifactGraphicInfo.getX() + artifactGraphicInfo .getWidth()) &gt; theMaxX) &#123; theMaxX = artifactGraphicInfo.getX() + artifactGraphicInfo.getWidth(); &#125; if (artifactGraphicInfo.getX() &lt; theMinX) &#123; theMinX = artifactGraphicInfo.getX(); &#125; // height if ((artifactGraphicInfo.getY() + artifactGraphicInfo .getHeight()) &gt; theMaxY) &#123; theMaxY = artifactGraphicInfo.getY() + artifactGraphicInfo.getHeight(); &#125; if (artifactGraphicInfo.getY() &lt; theMinY) &#123; theMinY = artifactGraphicInfo.getY(); &#125; &#125; List&lt;GraphicInfo&gt; graphicInfoList = bpmnModel .getFlowLocationGraphicInfo(artifact.getId()); if (graphicInfoList != null) &#123; for (GraphicInfo graphicInfo : graphicInfoList) &#123; // width if (graphicInfo.getX() &gt; theMaxX) &#123; theMaxX = graphicInfo.getX(); &#125; if (graphicInfo.getX() &lt; theMinX) &#123; theMinX = graphicInfo.getX(); &#125; // height if (graphicInfo.getY() &gt; theMaxY) &#123; theMaxY = graphicInfo.getY(); &#125; if (graphicInfo.getY() &lt; theMinY) &#123; theMinY = graphicInfo.getY(); &#125; &#125; &#125; &#125; int nrOfLanes = 0; for (org.activiti.bpmn.model.Process process : bpmnModel.getProcesses()) &#123; for (Lane l : process.getLanes()) &#123; nrOfLanes++; GraphicInfo graphicInfo = bpmnModel.getGraphicInfo(l.getId()); // // width if ((graphicInfo.getX() + graphicInfo.getWidth()) &gt; theMaxX) &#123; theMaxX = graphicInfo.getX() + graphicInfo.getWidth(); &#125; if (graphicInfo.getX() &lt; theMinX) &#123; theMinX = graphicInfo.getX(); &#125; // height if ((graphicInfo.getY() + graphicInfo.getHeight()) &gt; theMaxY) &#123; theMaxY = graphicInfo.getY() + graphicInfo.getHeight(); &#125; if (graphicInfo.getY() &lt; theMinY) &#123; theMinY = graphicInfo.getY(); &#125; &#125; &#125; // Special case, see http://jira.codehaus.org/browse/ACT-1431 if ((flowNodes.size() == 0) &amp;&amp; (bpmnModel.getPools().size() == 0) &amp;&amp; (nrOfLanes == 0)) &#123; // Nothing to show theMinX = 0; theMinY = 0; &#125; return new Point((int) theMinX, (int) theMinY); &#125; protected static List&lt;Artifact&gt; gatherAllArtifacts(BpmnModel bpmnModel) &#123; List&lt;Artifact&gt; artifacts = new ArrayList&lt;Artifact&gt;(); for (org.activiti.bpmn.model.Process process : bpmnModel.getProcesses()) &#123; artifacts.addAll(process.getArtifacts()); &#125; return artifacts; &#125; protected static List&lt;FlowNode&gt; gatherAllFlowNodes(BpmnModel bpmnModel) &#123; List&lt;FlowNode&gt; flowNodes = new ArrayList&lt;FlowNode&gt;(); for (org.activiti.bpmn.model.Process process : bpmnModel.getProcesses()) &#123; flowNodes.addAll(gatherAllFlowNodes(process)); &#125; return flowNodes; &#125; protected static List&lt;FlowNode&gt; gatherAllFlowNodes( FlowElementsContainer flowElementsContainer) &#123; List&lt;FlowNode&gt; flowNodes = new ArrayList&lt;FlowNode&gt;(); for (FlowElement flowElement : flowElementsContainer.getFlowElements()) &#123; if (flowElement instanceof FlowNode) &#123; flowNodes.add((FlowNode) flowElement); &#125; if (flowElement instanceof FlowElementsContainer) &#123; flowNodes .addAll(gatherAllFlowNodes((FlowElementsContainer) flowElement)); &#125; &#125; return flowNodes; &#125; public void drawHistoryFlow(BufferedImage image, String processInstanceId) &#123; HistoricProcessInstance historicProcessInstance = Context .getCommandContext().getHistoricProcessInstanceEntityManager() .findHistoricProcessInstance(processInstanceId); String processDefinitionId = historicProcessInstance .getProcessDefinitionId(); Graph graph = new ActivitiHistoryGraphBuilder(processInstanceId) .build(); for (Edge edge : graph.getEdges()) &#123; if (!boundaryType.contains(edge.getType()))&#123; drawSequenceFlow(image, processDefinitionId, edge.getName()); &#125; &#125; &#125; public void drawSequenceFlow(BufferedImage image, String processDefinitionId, String sequenceFlowId) &#123; GetBpmnModelCmd getBpmnModelCmd = new GetBpmnModelCmd( processDefinitionId); BpmnModel bpmnModel = getBpmnModelCmd.execute(Context .getCommandContext()); Graphics2D graphics = image.createGraphics(); graphics.setPaint(HISTORY_COLOR); graphics.setStroke(new BasicStroke(2f)); try &#123; List&lt;GraphicInfo&gt; graphicInfoList = bpmnModel .getFlowLocationGraphicInfo(sequenceFlowId); int[] xPoints = new int[graphicInfoList.size()]; int[] yPoints = new int[graphicInfoList.size()]; for (int i = 1; i &lt; graphicInfoList.size(); i++) &#123; GraphicInfo graphicInfo = graphicInfoList.get(i); GraphicInfo previousGraphicInfo = graphicInfoList.get(i - 1); if (i == 1) &#123; xPoints[0] = (int) previousGraphicInfo.getX() - minX; yPoints[0] = (int) previousGraphicInfo.getY() - minY; &#125; xPoints[i] = (int) graphicInfo.getX() - minX; yPoints[i] = (int) graphicInfo.getY() - minY; &#125; int radius = 15; Path2D path = new Path2D.Double(); for (int i = 0; i &lt; xPoints.length; i++) &#123; Integer anchorX = xPoints[i]; Integer anchorY = yPoints[i]; double targetX = anchorX; double targetY = anchorY; double ax = 0; double ay = 0; double bx = 0; double by = 0; double zx = 0; double zy = 0; if ((i &gt; 0) &amp;&amp; (i &lt; (xPoints.length - 1))) &#123; Integer cx = anchorX; Integer cy = anchorY; // pivot point of prev line double lineLengthY = yPoints[i] - yPoints[i - 1]; // pivot point of prev line double lineLengthX = xPoints[i] - xPoints[i - 1]; double lineLength = Math.sqrt(Math.pow(lineLengthY, 2) + Math.pow(lineLengthX, 2)); double dx = (lineLengthX * radius) / lineLength; double dy = (lineLengthY * radius) / lineLength; targetX = targetX - dx; targetY = targetY - dy; // isDefaultConditionAvailable = isDefault &amp;&amp; i == 1 &amp;&amp; lineLength &gt; 10; if ((lineLength &lt; (2 * radius)) &amp;&amp; (i &gt; 1)) &#123; targetX = xPoints[i] - (lineLengthX / 2); targetY = yPoints[i] - (lineLengthY / 2); &#125; // pivot point of next line lineLengthY = yPoints[i + 1] - yPoints[i]; lineLengthX = xPoints[i + 1] - xPoints[i]; lineLength = Math.sqrt(Math.pow(lineLengthY, 2) + Math.pow(lineLengthX, 2)); if (lineLength &lt; radius) &#123; lineLength = radius; &#125; dx = (lineLengthX * radius) / lineLength; dy = (lineLengthY * radius) / lineLength; double nextSrcX = xPoints[i] + dx; double nextSrcY = yPoints[i] + dy; if ((lineLength &lt; (2 * radius)) &amp;&amp; (i &lt; (xPoints.length - 2))) &#123; nextSrcX = xPoints[i] + (lineLengthX / 2); nextSrcY = yPoints[i] + (lineLengthY / 2); &#125; double dx0 = (cx - targetX) / 3; double dy0 = (cy - targetY) / 3; ax = cx - dx0; ay = cy - dy0; double dx1 = (cx - nextSrcX) / 3; double dy1 = (cy - nextSrcY) / 3; bx = cx - dx1; by = cy - dy1; zx = nextSrcX; zy = nextSrcY; &#125; if (i == 0) &#123; path.moveTo(targetX, targetY); &#125; else &#123; path.lineTo(targetX, targetY); &#125; if ((i &gt; 0) &amp;&amp; (i &lt; (xPoints.length - 1))) &#123; // add curve path.curveTo(ax, ay, bx, by, zx, zy); &#125; &#125; graphics.draw(path); // draw arrow Line2D.Double line = new Line2D.Double(xPoints[xPoints.length - 2], yPoints[xPoints.length - 2], xPoints[xPoints.length - 1], yPoints[xPoints.length - 1]); int ARROW_WIDTH = 5; int doubleArrowWidth = 2 * ARROW_WIDTH; Polygon arrowHead = new Polygon(); arrowHead.addPoint(0, 0); arrowHead.addPoint(-ARROW_WIDTH, -doubleArrowWidth); arrowHead.addPoint(ARROW_WIDTH, -doubleArrowWidth); AffineTransform transformation = new AffineTransform(); transformation.setToIdentity(); double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1); transformation.translate(line.x2, line.y2); transformation.rotate((angle - (Math.PI / 2d))); AffineTransform originalTransformation = graphics.getTransform(); graphics.setTransform(transformation); graphics.fill(arrowHead); graphics.setTransform(originalTransformation); &#125; finally &#123; graphics.dispose(); &#125; &#125; &#125; public interface ActivitiHelpService &#123; //查询历史节点id String findActHiActinstId(String taskId); /** * select id_ from ACT_HI_ACTINST where task_id_= #&#123;taskId&#125; */ //查询任务处理人的任务 List&lt;BpmTaskEntity&gt; page4AssigneeTask(QueryMap queryMap); /** * SELECT SUB.* FROM( * SELECT DISTINCT RES.*, row_number () OVER (ORDER BY RES.CREATE_TIME_ DESC) rnk * FROM ( * (SELECT DISTINCT * RES.*,pro.NAME_ as PROCESS_DEFNAME_, ca.name as CATEGORY_NAME_, * pc.START_USER_ID_ as PRO_START_USER_ID_,u.name as PRO_START_USER_NAME_, * run.status as PROCESS_STATUS_,run.PROCESS_INST_NAME,processconf.CAN_SHOWINMOBILE * FROM * ACT_RU_TASK RES * LEFT JOIN ACT_RE_PROCDEF pro on RES.PROC_DEF_ID_ = pro.ID_ * LEFT JOIN category ca on pro.CATEGORY_ = ca.id * LEFT JOIN ACT_HI_PROCINST pc on RES.PROC_INST_ID_ = pc.PROC_INST_ID_ * LEFT JOIN auth_user u on pc.START_USER_ID_ = u.account * LEFT JOIN bpm_process_run run on RES.PROC_INST_ID_ = run.process_inst_id * LEFT JOIN BPM_PROCESS_CONF processconf on processconf.PROCESS_DEF_KEY = pro.KEY_ * &lt;where&gt; * &lt;if test=\"assignee != null\"&gt; * AND RES.ASSIGNEE_ = #&#123;assignee&#125; * &lt;/if&gt; * &lt;if test=\"suspensionState != null\"&gt; * AND RES.SUSPENSION_STATE_ = #&#123;suspensionState&#125; * &lt;/if&gt; * &lt;if test=\"sapProcessIds != null and sapProcessIds != ''\"&gt; * AND pro.KEY_ NOT IN * &lt;foreach collection=\"sapProcessIds\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; * #&#123;item&#125; * &lt;/foreach&gt; * &lt;/if&gt; * &lt;if test=\"startCreateTime != null and startCreateTime !=''\"&gt; * &lt;![CDATA[ * AND RES.CREATE_TIME_ &gt;= #&#123;startCreateTime&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"endCreateTime != null and endCreateTime !=''\"&gt; * &lt;![CDATA[ * AND RES.CREATE_TIME_ &lt;= #&#123;endCreateTime&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"startDueTime != null and startDueTime !=''\"&gt; * &lt;![CDATA[ * AND RES.DUE_DATE_ &gt;= #&#123;startDueTime&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"endDueTime != null and endDueTime !=''\"&gt; * &lt;![CDATA[ * AND RES.DUE_DATE_ &lt;= #&#123;endDueTime&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"proInstId != null and proInstId !=''\"&gt; * &lt;![CDATA[ * AND RES.PROC_INST_ID_ = #&#123;proInstId&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"processDefId != null and processDefId !=''\"&gt; * &lt;![CDATA[ * AND RES.PROC_DEF_ID_ like #&#123;processDefId&#125; || '%' * ]]&gt; * &lt;/if&gt; * &lt;if test=\"processInstanceName != null and processInstanceName !=''\"&gt; * &lt;![CDATA[ * AND run.process_inst_name like '%'|| #&#123;processInstanceName&#125; || '%' * ]]&gt; * &lt;/if&gt; * &lt;if test=\"categoryId != null and categoryId !=''\"&gt; * &lt;![CDATA[ * AND ca.id = #&#123;categoryId&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"processStatus != null\"&gt; * AND run.status = #&#123;processStatus&#125; * &lt;/if&gt; * * &lt;if test=\"name != null and name !=''\"&gt; * &lt;![CDATA[ * AND RES.NAME_ like #&#123;name&#125; || '%' * ]]&gt; * &lt;/if&gt; * &lt;if test=\"conShowInMobile != null\"&gt; * AND processconf.CAN_SHOWINMOBILE= #&#123;conShowInMobile&#125; * &lt;/if&gt; * * &lt;/where&gt; * ) * * UNION * * (SELECT DISTINCT * RES.*,pro.NAME_ as PROCESS_DEFNAME_, ca.name as CATEGORY_NAME_, * pc.START_USER_ID_ as PRO_START_USER_ID_,u.name as PRO_START_USER_NAME_, * run.status as PROCESS_STATUS_,run.PROCESS_INST_NAME,processconf.CAN_SHOWINMOBILE * FROM * ACT_RU_TASK RES * INNER JOIN ACT_RU_IDENTITYLINK I ON I.TASK_ID_ = RES.ID_ * LEFT JOIN ACT_RE_PROCDEF pro on RES.PROC_DEF_ID_ = pro.ID_ * LEFT JOIN category ca on pro.CATEGORY_ = ca.id * LEFT JOIN ACT_HI_PROCINST pc on RES.PROC_INST_ID_ = pc.PROC_INST_ID_ * LEFT JOIN auth_user u on pc.START_USER_ID_ = u.account * LEFT JOIN bpm_process_run run on RES.PROC_INST_ID_ = run.process_inst_id * LEFT JOIN BPM_PROCESS_CONF processconf on processconf.PROCESS_DEF_KEY = pro.KEY_ * WHERE RES.ASSIGNEE_ IS NULL AND I.TYPE_ = 'candidate' * &lt;if test=\"assignee != null\"&gt; * AND I.USER_ID_ = #&#123;assignee&#125; * &lt;/if&gt; * &lt;if test=\"suspensionState != null\"&gt; * AND RES.SUSPENSION_STATE_ = #&#123;suspensionState&#125; * &lt;/if&gt; * &lt;if test=\"sapProcessIds != null and sapProcessIds != ''\"&gt; * AND pro.KEY_ NOT IN * &lt;foreach collection=\"sapProcessIds\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; * #&#123;item&#125; * &lt;/foreach&gt; * &lt;/if&gt; * &lt;if test=\"startCreateTime != null and startCreateTime !=''\"&gt; * &lt;![CDATA[ * AND RES.CREATE_TIME_ &gt;= #&#123;startCreateTime&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"endCreateTime != null and endCreateTime !=''\"&gt; * &lt;![CDATA[ * AND RES.CREATE_TIME_ &lt;= #&#123;endCreateTime&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"startDueTime != null and startDueTime !=''\"&gt; * &lt;![CDATA[ * AND RES.DUE_DATE_ &gt;= #&#123;startDueTime&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"endDueTime != null and endDueTime !=''\"&gt; * &lt;![CDATA[ * AND RES.DUE_DATE_ &lt;= #&#123;endDueTime&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"proInstId != null and proInstId !=''\"&gt; * &lt;![CDATA[ * AND RES.PROC_INST_ID_ = #&#123;proInstId&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"processDefId != null and processDefId !=''\"&gt; * &lt;![CDATA[ * AND RES.PROC_DEF_ID_ like #&#123;processDefId&#125; || '%' * ]]&gt; * &lt;/if&gt; * &lt;if test=\"categoryId != null and categoryId !=''\"&gt; * &lt;![CDATA[ * AND ca.id = #&#123;categoryId&#125; * ]]&gt; * &lt;/if&gt; * &lt;if test=\"processStatus != null\"&gt; * AND run.status = #&#123;processStatus&#125; * &lt;/if&gt; * &lt;if test=\"conShowInMobile != null\"&gt; * AND processconf.CAN_SHOWINMOBILE= #&#123;conShowInMobile&#125; * &lt;/if&gt; * ) * ) RES * ) SUB * &lt;![CDATA[ * WHERE SUB.rnk &gt;= #&#123;firstRow&#125; AND SUB.rnk &lt; #&#123;lastRow&#125; * ]]&gt; */ //查询已办任务 List&lt;BpmHisTaskEntity&gt; page4CompletedTask(QueryMap queryMap); /*SELECT SUB.* FROM( SELECT DISTINCT RES.*, row_number () OVER (ORDER BY RES.END_TIME_ DESC) rnk FROM ( SELECT DISTINCT RES.*, pro.NAME_ as PROCESS_DEFNAME_,run.PROCESS_INST_NAME , ca.name as CATEGORY_NAME_, pc.START_USER_ID_ as PRO_START_USER_ID_,u.name as PRO_START_USER_NAME_ FROM ACT_HI_TASKINST RES LEFT JOIN ACT_RE_PROCDEF pro on RES.PROC_DEF_ID_ = pro.ID_ LEFT JOIN category ca on pro.CATEGORY_ = ca.id LEFT JOIN ACT_HI_PROCINST pc ON RES.PROC_INST_ID_ = pc.PROC_INST_ID_ LEFT JOIN auth_user u on pc.START_USER_ID_ = u.account LEFT JOIN bpm_process_run run on RES.PROC_INST_ID_ = run.process_inst_id &lt;where&gt; &lt;if test=\"assignee != null\"&gt; AND RES.ASSIGNEE_ = #&#123;assignee&#125; &lt;/if&gt; AND RES.END_TIME_ IS NOT NULL &lt;if test=\"sapProcessIds != null and sapProcessIds != ''\"&gt; AND pro.KEY_ NOT IN &lt;foreach collection=\"sapProcessIds\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;if test=\"startCreateTime != null and startCreateTime !=''\"&gt; &lt;![CDATA[ AND RES.START_TIME_ &gt;= #&#123;startCreateTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"endCreateTime != null and endCreateTime !=''\"&gt; &lt;![CDATA[ AND RES.START_TIME_ &lt;= #&#123;endCreateTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"startFinishTime != null and startFinishTime !=''\"&gt; &lt;![CDATA[ AND RES.END_TIME_ &gt;= #&#123;startFinishTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"processInstanceName != null and processInstanceName !=''\"&gt; &lt;![CDATA[ AND run.process_inst_name like '%'|| #&#123;processInstanceName&#125; || '%' ]]&gt; &lt;/if&gt; &lt;if test=\"endFinishTime != null and endFinishTime !=''\"&gt; &lt;![CDATA[ AND RES.END_TIME_ &lt;= #&#123;endFinishTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"proInstId != null and proInstId !=''\"&gt; &lt;![CDATA[ AND RES.PROC_INST_ID_ = #&#123;proInstId&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"proInstApply != null and proInstApply !=''\"&gt; &lt;![CDATA[ AND pc.START_USER_ID_ = #&#123;proInstApply&#125; or u.name = #&#123;proInstApply&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"processDefId != null and processDefId !=''\"&gt; &lt;![CDATA[ AND RES.PROC_DEF_ID_ like #&#123;processDefId&#125; || '%' ]]&gt; &lt;/if&gt; &lt;if test=\"categoryId != null and categoryId !=''\"&gt; &lt;![CDATA[ AND ca.id = #&#123;categoryId&#125; ]]&gt; &lt;/if&gt; &lt;/where&gt; ) RES ) SUB &lt;![CDATA[ WHERE SUB.rnk &gt;= #&#123;firstRow&#125; AND SUB.rnk &lt; #&#123;lastRow&#125; ]]&gt;*/ //查询已办任务 Integer count4CompletedTask(QueryMap queryMap); /*SELECT SUB.* FROM( SELECT DISTINCT RES.*, row_number () OVER (ORDER BY RES.END_TIME_ DESC) rnk FROM ( SELECT DISTINCT RES.*, pro.NAME_ as PROCESS_DEFNAME_,run.PROCESS_INST_NAME , ca.name as CATEGORY_NAME_, pc.START_USER_ID_ as PRO_START_USER_ID_,u.name as PRO_START_USER_NAME_ FROM ACT_HI_TASKINST RES LEFT JOIN ACT_RE_PROCDEF pro on RES.PROC_DEF_ID_ = pro.ID_ LEFT JOIN category ca on pro.CATEGORY_ = ca.id LEFT JOIN ACT_HI_PROCINST pc ON RES.PROC_INST_ID_ = pc.PROC_INST_ID_ LEFT JOIN auth_user u on pc.START_USER_ID_ = u.account LEFT JOIN bpm_process_run run on RES.PROC_INST_ID_ = run.process_inst_id &lt;where&gt; &lt;if test=\"assignee != null\"&gt; AND RES.ASSIGNEE_ = #&#123;assignee&#125; &lt;/if&gt; AND RES.END_TIME_ IS NOT NULL &lt;if test=\"sapProcessIds != null and sapProcessIds != ''\"&gt; AND pro.KEY_ NOT IN &lt;foreach collection=\"sapProcessIds\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;if test=\"startCreateTime != null and startCreateTime !=''\"&gt; &lt;![CDATA[ AND RES.START_TIME_ &gt;= #&#123;startCreateTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"endCreateTime != null and endCreateTime !=''\"&gt; &lt;![CDATA[ AND RES.START_TIME_ &lt;= #&#123;endCreateTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"startFinishTime != null and startFinishTime !=''\"&gt; &lt;![CDATA[ AND RES.END_TIME_ &gt;= #&#123;startFinishTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"processInstanceName != null and processInstanceName !=''\"&gt; &lt;![CDATA[ AND run.process_inst_name like '%'|| #&#123;processInstanceName&#125; || '%' ]]&gt; &lt;/if&gt; &lt;if test=\"endFinishTime != null and endFinishTime !=''\"&gt; &lt;![CDATA[ AND RES.END_TIME_ &lt;= #&#123;endFinishTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"proInstId != null and proInstId !=''\"&gt; &lt;![CDATA[ AND RES.PROC_INST_ID_ = #&#123;proInstId&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"proInstApply != null and proInstApply !=''\"&gt; &lt;![CDATA[ AND pc.START_USER_ID_ = #&#123;proInstApply&#125; or u.name = #&#123;proInstApply&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"processDefId != null and processDefId !=''\"&gt; &lt;![CDATA[ AND RES.PROC_DEF_ID_ like #&#123;processDefId&#125; || '%' ]]&gt; &lt;/if&gt; &lt;if test=\"categoryId != null and categoryId !=''\"&gt; &lt;![CDATA[ AND ca.id = #&#123;categoryId&#125; ]]&gt; &lt;/if&gt; &lt;/where&gt; ) RES ) SUB &lt;![CDATA[ WHERE SUB.rnk &gt;= #&#123;firstRow&#125; AND SUB.rnk &lt; #&#123;lastRow&#125; ]]&gt;*/ //查询用户发起的流程 List&lt;BpmHisProcessInstanceEntity&gt; page4StartProcess(QueryMap queryMap); /*SELECT SUB.* FROM( SELECT RES.*, row_number () OVER (ORDER BY RES.START_TIME_ DESC) rnk FROM ( SELECT DISTINCT RES.*,DEF.NAME_ as PROCESS_DEFNAME_, ca.name as CATEGORY_NAME_,u.name as START_USER_NAME_, run.status as PROCESS_STATUS_,run.PROCESS_INST_NAME , checkUser.NAME as CHECKUSERNAME FROM ACT_HI_PROCINST RES INNER JOIN ACT_RE_PROCDEF DEF ON RES.PROC_DEF_ID_ = DEF.ID_ LEFT JOIN category ca on DEF.CATEGORY_ = ca.id LEFT JOIN auth_user u on RES.START_USER_ID_ = u.account LEFT JOIN bpm_process_run run on RES.PROC_INST_ID_ = run.process_inst_id LEFT JOIN ACT_RU_EXECUTION rutask on RES.PROC_INST_ID_ = rutask.PROC_INST_ID_ and rutask.is_active_=1 and rutask.is_scope_=1 LEFT JOIN ACT_HI_TASKINST task on RES.PROC_INST_ID_ = task.PROC_INST_ID_ and task.TASK_DEF_KEY_ =rutask.ACT_ID_ LEFT JOIN auth_user checkUser on task.assignee_ = checkUser.account &lt;where&gt; &lt;if test=\"assignee != null\"&gt; AND RES.START_USER_ID_ = #&#123;assignee&#125; &lt;/if&gt; &lt;if test=\"finished != null and finished == 'false'\"&gt; AND RES.END_TIME_ IS NULL &lt;/if&gt; &lt;if test=\"finished != null and finished == 'true'\"&gt; AND RES.END_TIME_ IS NOT NULL &lt;/if&gt; &lt;if test=\"sapProcessIds != null and sapProcessIds != ''\"&gt; AND DEF.KEY_ NOT IN &lt;foreach collection=\"sapProcessIds\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;if test=\"startCreateTime != null and startCreateTime !=''\"&gt; &lt;![CDATA[ AND RES.START_TIME_ &gt;= #&#123;startCreateTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"endCreateTime != null and endCreateTime !=''\"&gt; &lt;![CDATA[ AND RES.START_TIME_ &lt;= #&#123;endCreateTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"proInstId != null and proInstId !=''\"&gt; &lt;![CDATA[ AND RES.PROC_INST_ID_ = #&#123;proInstId&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"processDefId != null and processDefId !=''\"&gt; &lt;![CDATA[ AND RES.PROC_DEF_ID_ like #&#123;processDefId&#125; || '%' ]]&gt; &lt;/if&gt; &lt;if test=\"categoryId != null and categoryId !=''\"&gt; &lt;![CDATA[ AND ca.id = #&#123;categoryId&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"processStatus != null and processStatus !=''\"&gt; &lt;![CDATA[ AND run.status = #&#123;processStatus&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"proInstName != null and proInstName !=''\"&gt; &lt;![CDATA[ AND run.process_inst_name like '%'|| #&#123;proInstName&#125; || '%' ]]&gt; &lt;/if&gt; &lt;/where&gt; ) RES ) SUB &lt;![CDATA[ WHERE SUB.rnk &gt;= #&#123;firstRow&#125; AND SUB.rnk &lt; #&#123;lastRow&#125; ]]&gt;*/ //查询用户参与的流程 List&lt;BpmHisProcessInstanceEntity&gt; page4InvolvedUserProcess(QueryMap queryMap); /*SELECT SUB.* FROM( SELECT RES.*, row_number () OVER (ORDER BY RES.START_TIME_ DESC) rnk FROM ( SELECT DISTINCT RES.*,DEF.NAME_ as PROCESS_DEFNAME_, ca.name as CATEGORY_NAME_,u.name as START_USER_NAME_, run.status as PROCESS_STATUS_,run.PROCESS_INST_NAME , checkUser.NAME as CHECKUSERNAME, ruart.id_ as changeId,actinst.ACT_NAME_,AUTH_USER.Name user_Name FROM ACT_HI_PROCINST RES INNER JOIN ACT_RE_PROCDEF DEF ON RES.PROC_DEF_ID_ = DEF.ID_ LEFT JOIN category ca on DEF.CATEGORY_ = ca.id LEFT JOIN auth_user u on RES.START_USER_ID_ = u.account LEFT JOIN bpm_process_run run on RES.PROC_INST_ID_ = run.process_inst_id LEFT JOIN ACT_RU_EXECUTION rutask on RES.PROC_INST_ID_ = rutask.PROC_INST_ID_ and rutask.is_active_=1 and rutask.is_scope_=1 left join act_ru_task ruart on rutask.id_=ruart.execution_id_ LEFT JOIN ACT_HI_TASKINST task on RES.PROC_INST_ID_ = task.PROC_INST_ID_ and task.TASK_DEF_KEY_ =rutask.ACT_ID_ LEFT JOIN auth_user checkUser on task.assignee_ = checkUser.account LEFT JOIN bpm_role_procdef bpm on bpm.procdef_key = DEF.KEY_ LEFT JOIN bpm_user_role role on role.role_id = bpm.role_id LEFT JOIN ACT_HI_ACTINST actinst on actinst.PROC_INST_ID_=RES.PROC_INST_ID_ and actinst.ACT_NAME_='业务顾问导出数据' left join AUTH_USER on AUTH_USER.Account=actinst.assignee_ &lt;where&gt; &lt;if test=\"sapProcessIds != null and sapProcessIds !=''\"&gt; AND DEF.KEY_ NOT IN &lt;foreach collection=\"sapProcessIds\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;if test=\"startCreateTime != null and startCreateTime !=''\"&gt; &lt;![CDATA[ AND RES.START_TIME_ &gt;= #&#123;startCreateTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"endCreateTime != null and endCreateTime !=''\"&gt; &lt;![CDATA[ AND RES.START_TIME_ &lt;= #&#123;endCreateTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"startFinishTime != null and startFinishTime !=''\"&gt; &lt;![CDATA[ AND RES.END_TIME_ &gt;= #&#123;startFinishTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"endFinishTime != null and endFinishTime !=''\"&gt; &lt;![CDATA[ AND RES.END_TIME_ &lt;= #&#123;endFinishTime&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"proInstId != null and proInstId !=''\"&gt; &lt;![CDATA[ AND RES.PROC_INST_ID_ = #&#123;proInstId&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"processDefId != null and processDefId !=''\"&gt; &lt;![CDATA[ AND RES.PROC_DEF_ID_ like #&#123;processDefId&#125; || '%' ]]&gt; &lt;/if&gt; &lt;if test=\"categoryId != null and categoryId !=''\"&gt; &lt;![CDATA[ AND ca.id = #&#123;categoryId&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"processInstanceName != null and processInstanceName !=''\"&gt; &lt;![CDATA[ AND run.process_inst_name like '%'|| #&#123;processInstanceName&#125; || '%' ]]&gt; &lt;/if&gt; &lt;if test=\"proInstApply!= null and proInstApply!=''\"&gt; &lt;![CDATA[ AND u.name = #&#123;proInstApply&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"finished != null and finished == 'false'\"&gt; AND RES.END_TIME_ IS NULL &lt;/if&gt; &lt;if test=\"finished != null and finished == 'true'\"&gt; AND RES.END_TIME_ IS NOT NULL &lt;/if&gt; &lt;if test=\"userId != null \"&gt; AND role.user_id = #&#123;userId&#125; &lt;/if&gt; &lt;if test=\"processStatus != null and processStatus !=''\"&gt; &lt;![CDATA[ AND run.status = #&#123;processStatus&#125; ]]&gt; &lt;/if&gt; &lt;if test=\"assigneeUser != null \"&gt; AND AUTH_USER.name = #&#123;assigneeUser&#125; &lt;/if&gt; &lt;if test=\"proInstName != null \"&gt; AND run.process_inst_name like CONCAT(CONCAT('%',#&#123;proInstName&#125;),'%') &lt;/if&gt; &lt;!-- &lt;if test=\"actName != null \"&gt; AND actinst.ACT_NAME_ = #&#123;actName&#125; &lt;/if&gt; --&gt; AND ( EXISTS ( SELECT LINK.USER_ID_ FROM ACT_HI_IDENTITYLINK LINK &lt;where&gt; &lt;if test=\"assignee != null\"&gt; AND USER_ID_ = #&#123;assignee&#125; &lt;/if&gt; AND LINK.PROC_INST_ID_ = RES.ID_ &lt;/where&gt; ) ) &lt;/where&gt; ) RES ) SUB &lt;![CDATA[ WHERE SUB.rnk &gt;= #&#123;firstRow&#125; AND SUB.rnk &lt; #&#123;lastRow&#125; ]]&gt;*/ &#125; /** * The class &lt;code&gt;GetRenderedTaskHistoryFormCmd&lt;/code&gt; * 获取历史的任务表单 */ public class GetRenderedTaskHistoryFormCmd implements Command&lt;Object&gt;, Serializable &#123; private static final long serialVersionUID = 5039164042361021480L; protected String processInstanceId; protected String formEngineName; public GetRenderedTaskHistoryFormCmd(String processInstanceId, String formEngineName) &#123; super(); this.processInstanceId = processInstanceId; this.formEngineName = formEngineName; &#125; @Override public Object execute(CommandContext commandContext) &#123; FormEngine formEngine = Context .getProcessEngineConfiguration() .getFormEngines() .get(formEngineName); if (formEngine == null) &#123; throw new ActivitiException(\"No formEngine '\" + formEngineName +\"' defined process engine configuration\"); &#125; SpringProcessEngineConfiguration engineConfig = (SpringProcessEngineConfiguration) SpringTools.getBean(\"processEngineConfiguration\"); Map&lt;String, FormEngine&gt; engines = engineConfig.getFormEngines(); FreemarkerFormEngine freeMarkerEngine = (FreemarkerFormEngine) engines.get(\"freemarker\"); return freeMarkerEngine.renderHisProcessForm(processInstanceId, engineConfig); &#125; &#125; /** * FreeMark表单引擎 */ public class FreemarkerFormEngine implements FormEngine &#123; private static final Logger logger = LoggerFactory.getLogger(FreemarkerFormEngine.class); //Global private static final String CONTEXT_RANDOM_VALUE = \"rand\"; private static final String CONTEXT_BASE_VALUE = \"base\"; private static final String CONTEXT_APP_USER = \"appuser\"; private static final String CURRENT_STEP = \"currentStep\"; //Task private static final String CURRENT_STEP_NAME = \"currentStepName\"; //TaskName private static final String FREEMARKER_ENGINE_NAME = \"freemarker\"; //Engine Name private static final String PROCESS_INSTANCE_ID = \"processInstanceId\"; private static final String PROCESS_HISTORY_VARIABLE = \"proHisVar\"; //Configs private Configuration cfg; private String formDir; private String base; private String file_upload_url; private String file_download_url; private String file_param_iframeUrl; private String file_param_syId; private String file_param_syNm; private String file_param_diyFolder; private String file_parma_uploadType; private String file_param_fileVersion; private BpmService bpmService; public void setFreemarkerConfig(Configuration configuration) &#123; cfg = configuration; &#125; public void setFormDir(String formDir) &#123; if (StringUtils.isEmpty(formDir)) &#123; this.formDir = formDir; &#125; else if (!formDir.endsWith(\"/\")) &#123; this.formDir = formDir + \"/\"; &#125; &#125; public void setBase(String base) &#123; this.base = base; &#125; public void setFile_upload_url(String file_upload_url) &#123; this.file_upload_url = file_upload_url; &#125; public void setFile_download_url(String file_download_url) &#123; this.file_download_url = file_download_url; &#125; public void setFile_param_iframeUrl(String file_param_iframeUrl) &#123; this.file_param_iframeUrl = file_param_iframeUrl; &#125; public void setFile_param_syId(String file_param_syId) &#123; this.file_param_syId = file_param_syId; &#125; public void setFile_param_syNm(String file_param_syNm) &#123; this.file_param_syNm = file_param_syNm; &#125; public void setFile_param_diyFolder(String file_param_diyFolder) &#123; this.file_param_diyFolder = file_param_diyFolder; &#125; public void setFile_parma_uploadType(String file_parma_uploadType) &#123; this.file_parma_uploadType = file_parma_uploadType; &#125; public void setFile_param_fileVersion(String file_param_fileVersion) &#123; this.file_param_fileVersion = file_param_fileVersion; &#125; @Override public String getName() &#123; return FREEMARKER_ENGINE_NAME; &#125; /** * 渲染开始表单 */ @Override public Object renderStartForm(StartFormData startForm) &#123; //设置全局变量 Map&lt;String, Object&gt; model = new LinkedHashMap&lt;String,Object&gt;(); //获取开始节点 RepositoryService repositoryService = Context.getProcessEngineConfiguration().getRepositoryService(); BpmnModel bpmModel = repositoryService.getBpmnModel(startForm.getProcessDefinition().getId()); List&lt;org.activiti.bpmn.model.Process&gt; processList = bpmModel.getProcesses(); for (org.activiti.bpmn.model.Process process : processList) &#123; List&lt;FlowElement&gt; eleList = (List&lt;FlowElement&gt;) process.getFlowElements(); for (FlowElement ele : eleList) &#123; if (ele instanceof StartEvent) &#123; StartEvent startEle = (StartEvent) ele; logger.debug(\"[startEle.getId()]--&gt;\" + startEle.getId()); //开始节点 model.put(CURRENT_STEP, startEle.getId()); model.put(CURRENT_STEP_NAME, startEle.getName()); break; &#125; &#125; &#125; model = initGlobalModel(model); return getFormTemplateString(startForm.getProcessDefinition().getKey(), startForm, model); &#125; /** * 渲染任务表单 */ @Override public Object renderTaskForm(TaskFormData taskForm) &#123; TaskEntity task = (TaskEntity) taskForm.getTask(); Map&lt;String,Object&gt; model = task.getExecution().getProcessVariables(); //获取流程变量 bpmService = (BpmService) SpringTools.getBean(BpmService.class); model = bpmService.getHisProcesVariable(model, task.getProcessInstanceId(), false); model = initGlobalModel(model); ProcessHisVariable proHisVar = bpmService.getAllHisVariables(task.getProcessInstanceId()); model.put(PROCESS_HISTORY_VARIABLE, proHisVar); model.put(CURRENT_STEP, task.getTaskDefinitionKey()); model.put(CURRENT_STEP_NAME, task.getName()); model.put(PROCESS_INSTANCE_ID, task.getProcessInstanceId()); String[] processKey = task.getProcessDefinitionId().split(\":\"); return getFormTemplateString(processKey[0], taskForm, model); &#125; /** * 渲染批量操作时任务表单 */ public Object renderBatchTaskForm(TaskFormData taskForm) &#123; TaskEntity task = (TaskEntity) taskForm.getTask(); Map&lt;String,Object&gt; model = task.getExecution().getProcessVariables(); model = initGlobalModel(model); bpmService = (BpmService) SpringTools.getBean(BpmService.class); ProcessHisVariable proHisVar = bpmService.getAllHisVariables(task.getProcessInstanceId()); model.put(PROCESS_HISTORY_VARIABLE, proHisVar); model.put(CURRENT_STEP, task.getTaskDefinitionKey()); model.put(CURRENT_STEP_NAME, task.getName()); model.put(PROCESS_INSTANCE_ID, task.getProcessInstanceId()); String[] processKey = task.getProcessDefinitionId().split(\":\"); return getFormTemplateString4Batch(processKey[0], taskForm, model); &#125; /** * 渲染流程历史表单 */ public Object renderHisProcessForm(String processInstanceId, ProcessEngineConfiguration engineConfig) &#123; Map&lt;String,Object&gt; model = new LinkedHashMap&lt;String,Object&gt;(); //历史服务 HistoryService historyService = engineConfig.getHistoryService(); //获取流程变量 bpmService = (BpmService) SpringTools.getBean(BpmService.class); model = bpmService.getHisProcesVariable(model, processInstanceId,false); ProcessHisVariable proHisVar = bpmService.getAllHisVariables(processInstanceId);//获取历史变量 model.put(PROCESS_HISTORY_VARIABLE, proHisVar); model = initGlobalModel(model); HistoricProcessInstance processInstance = historyService.createHistoricProcessInstanceQuery() .processInstanceId(processInstanceId).singleResult(); String deploymentId = engineConfig.getRepositoryService() .getProcessDefinition(processInstance.getProcessDefinitionId()).getDeploymentId(); //构造一个TaskFormData TaskFormDataImpl formData = new TaskFormDataImpl(); formData.setDeploymentId(deploymentId); formData.setFormKey(null); String[] processKey = processInstance.getProcessDefinitionId().split(\":\"); return getFormTemplateString(processKey[0], formData, model); &#125; /** * 渲染流程历史打印表单 * @param processInstanceId * @param engineConfig * @return */ public Object renderHisProcessPrintForm(String processInstanceId, ProcessEngineConfiguration engineConfig) &#123; Map&lt;String,Object&gt; model = new LinkedHashMap&lt;String,Object&gt;(); //历史服务 HistoryService historyService = engineConfig.getHistoryService(); //获取流程变量 bpmService = (BpmService) SpringTools.getBean(BpmService.class); model = bpmService.getEntireProcesVariable(model, processInstanceId,false); ProcessHisVariable proHisVar = bpmService.getAllHisVariables(processInstanceId); model.put(PROCESS_HISTORY_VARIABLE, proHisVar); model = initGlobalModel(model); HistoricProcessInstance processInstance = historyService.createHistoricProcessInstanceQuery() .processInstanceId(processInstanceId).singleResult(); String deploymentId = engineConfig.getRepositoryService() .getProcessDefinition(processInstance.getProcessDefinitionId()).getDeploymentId(); //构造一个TaskFormData TaskFormDataImpl formData = new TaskFormDataImpl(); formData.setDeploymentId(deploymentId); formData.setFormKey(null); String[] processKey = processInstance.getProcessDefinitionId().split(\":\"); return getFormTemplateString(processKey[0], formData, model); &#125; /** * 根据模板填充数据 * @param processDefinitionKey * @param formInstance * @param model * @return */ protected String getFormTemplateString(String processDefinitionKey, FormData formInstance, Map&lt;String,Object&gt; model) &#123; String deploymentId = formInstance.getDeploymentId(); String formKey = formInstance.getFormKey(); if (formKey == null) &#123; formKey = getProcessDefPerfix(processDefinitionKey)+\".html\"; &#125; String name = null; if (StringUtils.isEmpty(formDir)) &#123; name = deploymentId + \";\" + formKey; &#125; else &#123; name = formDir + processDefinitionKey + \"/\" + formKey; &#125; try &#123; Template temp = cfg.getTemplate(name); Writer out = new StringWriter(); temp.process(model, out); return out.toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 根据模板填充批量操作数据 * @param processDefinitionKey * @param formInstance * @param model * @return */ protected String getFormTemplateString4Batch(String processDefinitionKey, FormData formInstance, Map&lt;String,Object&gt; model) &#123; String deploymentId = formInstance.getDeploymentId(); String formKey = formInstance.getFormKey(); if (formKey == null) &#123; formKey = getProcessDefPerfix(processDefinitionKey)+\".html\"; &#125; String name = null; if (StringUtils.isEmpty(formDir)) &#123; if(processDefinitionKey.equals(\"M-Leave-Application\")) name = deploymentId + \";\" + getProcessDefPerfix(processDefinitionKey)+\"-batchform.html\"; else name = deploymentId + \";\" + formKey; &#125;else if(processDefinitionKey.equals(\"M-Leave-Application\")) name = formDir + processDefinitionKey + \"/\" + getProcessDefPerfix(processDefinitionKey)+\"-batchform.html\"; else name = formDir + processDefinitionKey + \"/\" + formKey; try &#123; Template temp = cfg.getTemplate(name); Writer out = new StringWriter(); temp.process(model, out); return out.toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TemplateException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 初始化FreeMarker表单全局变量 * @param model * @return */ private Map&lt;String, Object&gt; initGlobalModel(Map&lt;String, Object&gt; model)&#123; AppUser user = AppContext.getCurrentAppUser(); if (user != null) &#123; model.put(CONTEXT_APP_USER, user); &#125; model.put(CONTEXT_RANDOM_VALUE, (\"\"+Math.random()).substring(2, 8)); model.put(CONTEXT_BASE_VALUE, base); //GnFS model.put(BPMConstant.FILE_UPLOAD_URL, file_upload_url); model.put(BPMConstant.FILE_DOWNLOAD_URL, file_download_url); model.put(BPMConstant.FILE_PARAM_IFRAMEURL, file_param_iframeUrl); model.put(BPMConstant.FILE_PARAM_SYID, file_param_syId); model.put(BPMConstant.FILE_PARAM_SYNM, file_param_syNm); model.put(BPMConstant.FILE_PARAM_DIYFOLDER, file_param_diyFolder); model.put(BPMConstant.FILE_PARAM_UPLOADTYPE, file_parma_uploadType); model.put(BPMConstant.FILE_PARAM_FILEVERSION, file_param_fileVersion); model.put(BPMConstant.CURRENT_PARAM_DATE, new Date().toLocaleString()); return model; &#125; /** * 获取流程定义的前缀 * @param processDefinitionKey * @return */ private String getProcessDefPerfix(String processDefinitionKey)&#123; String[] keyArr = processDefinitionKey.split(\":\"); return keyArr[0]; &#125; &#125; Activiti5.13 框架 数据库设计说明书1、结构设计 1.1、 逻辑结构设计 Activiti使用到的表都是ACT_开头的。 ACT_RE_*: &#39;RE&#39;表示repository( 存储 )，RepositoryService接口所操作的表。带此前缀的表包含的是静态信息，如，流程定义，流程的资源（图片，规则等）。 ACT_RU_*: &#39;RU&#39;表示runtime，运行时表-RuntimeService。这是运行时的表存储着流程变量，用户任务，变量，职责（job）等运行时的数据。Activiti只存储实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就保证了这些运行时的表小且快。 ACT_ID_*: &#39;ID&#39;表示identity ( 组织机构 )，IdentityService接口所操作的表。用户记录，流程中使用到的用户和组。这些表包含标识的信息，如用户，用户组，等等。 ACT_HI_*: &#39;HI&#39;表示history，历史数据表，HistoryService。就是这些表包含着流程执行的历史相关数据，如结束的流程实例，变量，任务，等等 ACT_GE_*: 全局通用数据及设置(general)，各种情况都使用的数据。 1.2、 所有表的含义 序号 表名 说明 1 act_ge_bytearray 二进制数据表 2 act_ge_property 属性数据表存储整个流程引擎级别的数据,初始化表结构时，会默认插入三条记录， 3 act_hi_actinst 历史节点表 4 act_hi_attachment 历史附件表 5 act_hi_comment 历史意见表 6 act_hi_identitylink 历史流程人员表 7 act_hi_detail 历史详情表，提供历史变量的查询 8 act_hi_ procinst 历史流程实例表 9 act_hi_taskinst 历史任务实例表 10 act_hi_varinst 历史变量表 11 act_id_group 用户组信息表 12 act_id_info 用户扩展信息表 13 act_id_membership 用户与用户组对应信息表 14 act_id_user 用户信息表 15. act_re_deployment 部署信息表 16. act_re_model 流程设计模型部署表 17 act_re_procdef 流程定义数据表 18 act_ru_event_subscr ？ 19 act_ru_execution 运行时流程执行实例表 20 act_ru_identitylink 运行时流程人员表，主要存储任务节点与参与者的相关信息 21 act_ru_job 运行时定时任务数据表 22 act_ru_task 运行时任务节点表 23 act_ru_variable 运行时流程变量数据表 2、 表以及索引信息 2.1 二进制数据表（act_ge_bytearray） 2.1.1 简要描述 保存流程定义图片和xml、Serializable(序列化)的变量,即保存所有二进制数据，特别注意 类路径部署时候 ，不要把svn等隐藏文件或者其他与流程无关的文件也一起部署到该表中，会造成一些错误（可能导致流程定义无法删除）。 2.1.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID REV_ 乐观锁 int √ Version(版本) NAME_ 名称 nvarchar(255) √ 部署的文件名称，如：mail.bpmn、mail.png 、mail.bpmn20.xml DEPLOYMENT_ID_ 部署ID nvarchar(64) √ 部署表ID BYTES_ 字节 varbinary(max) √ 部署文件 GENERATED_ 是否是引擎生成 tinyint √ 0为用户生成 1为Activiti生成 2.1.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_FK_BYTEARR_DEPL DEPLOYMENT_ID_ 2.2 属性数据表( act_ge_property ) 2.2.1 简要描述 属性数据表。存储整个流程引擎级别的数据。 2.2.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 NAME_ 名称 nvarchar(64) √ schema.versionschema.historynext.dbid VALUE_ 值 nvarchar(300) √ 5.*create(5.*) REV_ 乐观锁 int √ version 2.2.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY NAME_ Unique 主键唯一索引 2.3 历史节点表（act_hi_actinst） 2.3.1 简要描述 历史活动信息。这里记录流程流转过的所有节点，与HI_TASKINST不同的是，taskinst只记录usertask内容 2.3.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ PROC_DEF_ID_ 流程定义ID nvarchar(64) PROC_INST_ID_ 流程实例ID nvarchar(64) EXECUTION_ID_ 执行实例ID nvarchar(64) ACT_ID_ 节点ID nvarchar(225) 节点定义ID TASK_ID_ 任务实例ID nvarchar(64) √ 任务实例ID 其他节点类型实例ID在这里为空 CALL_PROC_INST_ID_ 调用外部的流程实例ID nvarchar(64) √ 调用外部流程的流程实例ID&#39; ACT_NAME_ 节点名称 nvarchar(225) √ 节点定义名称 ACT_TYPE_ 节点类型 nvarchar(225) 如startEvent、userTask ASSIGNEE_ 签收人 nvarchar(64) √ 节点签收人 START_TIME_ 开始时间 datetime 2013-09-15 11:30:00 END_TIME_ 结束时间 datetime √ 2013-09-15 11:30:00 DURATION_ 耗时 numeric(19,0) √ 毫秒值 2.3.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_IDX_HI_ACT_INST_START START_TIME_ ACT_IDX_HI_ACT_INST_END END_TIME_ ACT_IDX_HI_ACT_INST_PROCINST PROC_INST_ID_ 、 ACT_ID_ ACT_IDX_HI_ACT_INST_EXEC EXECUTION_ID_ 、 ACT_ID_ 2.4 历史附件表( act_hi_attachment ) 2.4.1 简要描述 历史附件表。 2.4.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID REV_ 乐观锁 integer √ Version USER_ID_ 用户ID nvarchar(255) √ 用户ID NAME_ 名称 nvarchar(255) √ 附件名称 DESCRIPTION_ 描述 nvarchar(4000) √ 描述 TYPE_ 类型 nvarchar(255) √ 附件类型 TASK_ID_ 任务实例ID nvarchar(64) √ 节点实例ID PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID URL_ URL_ nvarchar(4000) √ 附件地址 CONTENT_ID_ 字节表的ID nvarchar(64) √ ACT_GE_BYTEARRAY的ID 2.4.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 2.5 历史意见表( act_hi_comment ) 2.5.1 简要描述 历史意见表。 2.5.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID TYPE_ 类型 nvarchar(255) √ 类型：event（事件）comment（意见） TIME_ 时间 datetime 填写时间&#39; USER_ID_ 用户ID nvarchar(64) √ 填写人 TASK_ID_ 节点任务ID nvarchar(64) √ 节点实例ID PROC_INST_ID_ 流程实例ID nvarchar(255) √ 流程实例ID ACTION_ 行为类型 nvarchar(64) √ 见备注1 MESSAGE_ 基本内容 nvarchar(4000) √ 用于存放流程产生的信息，比如审批意见 FULL_MSG_ 全部内容 varbinary(max) √ 附件地址 2.5.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 2.6 历史详情表( act_hi_detail ) 2.6.1 简要描述 历史详情表：流程中产生的变量详细，包括控制流程流转的变量，业务表单中填写的流程需要用到的变量等。 2.6.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键 TYPE_ 类型 nvarchar(255) 见备注2 PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID EXECUTION_ID_ 执行实例ID nvarchar(64) √ 执行实例ID TASK_ID_ 任务实例ID nvarchar(64) √ 任务实例ID ACT_INST_ID_ 节点实例ID nvarchar(64) √ ACT_HI_ACTINST表的ID NAME_ 名称 nvarchar(255) 名称 VAR_TYPE_ 参数类型 nvarchar(255) √ 见备注3 REV_ 乐观锁 int √ Version TIME_ 时间戳 datetime 创建时间 BYTEARRAY_ID_ 字节表ID nvarchar √ ACT_GE_BYTEARRAY表的ID DOUBLE_ DOUBLE_ double precision √ 存储变量类型为Double LONG_ LONG_ numeric √ 存储变量类型为long TEXT_ TEXT_ nvarchar √ 存储变量值类型为String TEXT2_ TEXT2_ nvarchar √ 此处存储的是JPA持久化对象时，才会有值。此值为对象ID 2.6.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_IDX_HI_ACT_INST_START START_TIME_ ACT_IDX_HI_ACT_INST_END END_TIME_ ACT_IDX_HI_ACT_INST_PROCINST PROC_INST_ID_ 、 ACT_ID_ ACT_IDX_HI_ACT_INST_EXEC EXECUTION_ID_ 、 ACT_ID_ 2.7 历史流程人员表( act_ru_identitylink ) 2.7.1 简要描述 任务参与者数据表。主要存储历史节点参与者的信息。 2.7.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ ID_ GROUP_ID_ 组ID nvarchar(255) √ 组ID TYPE_ 类型 nvarchar(255) √ 备注4 USER_ID_ 用户ID nvarchar(255) √ 用户ID TASK_ID_ 节点实例ID nvarchar(64) √ 节点实例ID PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID 2.7.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_IDX_HI_IDENT_LNK_USER USER_ID_ Unique ACT_IDX_HI_IDENT_LNK_TASK TASK_ID_ ACT_IDX_HI_IDENT_LNK_PROCINST PROC_INST_ID_ 2.8 历史流程实例表（act_hi_procinst） 2.8.1 简要描述 历史流程实例表。 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID PROC_INST_ID_ 流程实例ID nvarchar(64) 流程实例ID BUSINESS_KEY_ 业务主键 nvarchar(255) √ 业务主键，业务表单的ID PROC_DEF_ID_ 流程定义ID nvarchar(64) 流程定义ID START_TIME_ 开始时间 datetime 开始时间 END_TIME_ 结束时间 datetime √ 结束时间 DURATION_ 耗时 Numeric(19) √ 耗时 START_USER_ID_ 起草人 nvarchar(255) √ 起草人 START_ACT_ID_ 开始节点ID nvarchar(255) √ 起草环节ID END_ACT_ID_ 结束节点ID nvarchar(255) √ 结束环节ID SUPER_PROCESS_INSTANCE_ID_ 父流程实例ID nvarchar(64) √ 父流程实例ID DELETE_REASON_ 删除原因 nvarchar(4000) √ 删除原因 2.8.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 PROC_INST_ID_ PROC_INST_ID_ Unique 外键 ACT_UNIQ_HI_BUS_KEY PROC_DEF_ID_,BUSINESS_KEY_ Unique ACT_IDX_HI_PRO_INST_END END_TIME_ ACT_IDX_HI_PRO_I_BUSKEY BUSINESS_KEY_ 2.9 历史任务实例表( act_hi_taskinst ) 2.9.1 简要描述 历史任务实例表。 2.9.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID PROC_DEF_ID_ 流程定义ID nvarchar(64) √ 流程定义ID TASK_DEF_KEY_ 节点定义ID nvarchar(255) √ 节点定义ID PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID EXECUTION_ID_ 执行实例ID nvarchar(64) √ 执行实例ID NAME_ 名称 varchar(255) √ 名称 PARENT_TASK_ID_ 父节点实例ID nvarchar(64) √ 父节点实例ID DESCRIPTION_ 描述 nvarchar(400) √ 描述 OWNER_ 实际签收人 任务的拥有者 nvarchar(255) √ 签收人（默认为空，只有在委托时才有值） ASSIGNEE_ 签收人或被委托 nvarchar(255) √ 签收人或被委托 START_TIME_ 开始时间 datetime 开始时间 CLAIM_TIME_ 提醒时间 datetime √ 提醒时间 END_TIME_ 结束时间 datetime √ 结束时间 DURATION_ 耗时 numeric(19) √ 耗时 DELETE_REASON_ 删除原因 nvarchar(4000) √ 删除原因(completed,deleted) PRIORITY_ 优先级别 int √ 优先级别 DUE_DATE_ 过期时间 datetime √ 过期时间，表明任务应在多长时间内完成 FORM_KEY_ 节点定义的formkey nvarchar(255) √ desinger节点定义的form_key属性 2.9.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 2.10 历史变量表( act_hi_varinst ) 2.10.1 简要描述 历史变量表。 2.10.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ ID_ PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID EXECUTION_ID_ 执行实例ID nvarchar(255) √ 执行实例ID TASK_ID_ 任务实例ID nvarchar(64) √ 任务实例ID NAME_ 名称 nvarchar(64) 参数名称(英文) VAR_TYPE_ 参数类型 varchar(255) √ 备注5 REV_ 乐观锁 nvarchar(64) √ 乐观锁 Version BYTEARRAY_ID_ 字节表ID nvarchar(400) √ ACT_GE_BYTEARRAY表的主键 DOUBLE_ DOUBLE_ nvarchar(255) √ 存储DoubleType类型的数据 LONG_ LONG_ nvarchar(255) √ 存储LongType类型的数据 TEXT_ TEXT_ datetime √ 备注6 TEXT2_ TEXT2_ datetime √ 此处存储的是JPA持久化对象时，才会有值。此值为对象ID 2.10.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_IDX_HI_PROCVAR_PROC_INST PROC_INST_ID_ ACT_IDX_HI_PROCVAR_NAME_TYPE NAME_, VAR_TYPE_ 2.11 用户组信息表( act_id_group ) 2.11.1 简要描述 用来存储用户组信息。 2.11.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID REV_ 乐观锁 int √ 乐观锁Version NAME_ 名称 nvarchar(255) √ 组名称 TYPE_ 类型 nvarchar(255) √ 类型 2.11.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 2.12 用户扩展信息表( act_id_info ) 2.12.1 简要描述 用户扩展信息表。目前该表未用到 ~~~~~ · 2.12.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID REV_ 乐观锁 int √ 乐观锁Version USER_ID_ 用户ID nvarchar(64) √ TYPE_ 类型 nvarchar(64) √ KEY_ nvarchar(255) √ VALUE_ nvarchar(255) √ PASSWORD_ Image √ PARENT_ID_ nvarchar(255) √ 2.12.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 2.13 用户与分组对应信息表( act_id_membership ) 2.13.1 简要描述 用来保存用户的分组信息。 2.13.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 USER_ID 用户ID nvarchar(64) √ GROUP_ID 用户组ID nvarchar(64) √ 2.13.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY USER_ID_, GROUP_ID_ Unique 主键唯一索引 ACT_FK_MEMB_GROUP GROUP_ID_ 2.14 用户信息表( act_id_user ) 2.14.1 简要描述 工作流用户信息 2.14.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID REV_ 乐观锁 int √ 乐观锁Version FIRST_ 姓 nvarchar(255) √ LAST_ 名 nvarchar(255) √ EMAIL_ EMAIL_ nvarchar(255) √ PWD_ 密码 nvarchar(255) √ PICTURE_ID_ 图片ID nvarchar(64) √ 2.14.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 2.15 部署信息表( act_re_deployment ) 2.15.1 简要描述 部署流程定义时需要被持久化保存下来的信息。 2.15.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键ID NAME_ 部署名称 nvarchar(255) √ 部署文件名 CATEGORY_ 分类 nvarchar(255) √ 类别 DEPLOY_TIME_ 部署时间 datetime √ 部署时间 2.15.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 2.16 流程设计模型部署表( act_re_model ) 2.16.1 简要描述 流程设计器设计流程后，保存数据到该表。 2.16.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ ID_ REV_ 乐观锁 int √ 乐观锁 NAME_ 名称 nvarchar(255) √ 名称 KEY_ KEY_ nvarchar(255) √ 分类，例如： http://www.mossle.com/docs/activiti/ CATEGORY_ 分类 nvarchar(255) √ 分类 CREATE_TIME_ 创建时间 datetime √ 创建时间 LAST_UPDATE_TIME_ 最新修改时间 datetime √ 最新修改时间 VERSION_ 版本 int √ 版本 META_INFO_ META_INFO_ nvarchar(255) √ 以json格式保存流程定义的信息 DEPLOYMENT_ID_ 部署ID nvarchar(255) √ 部署ID EDITOR_SOURCE_VALUE_ID_ datetime √ EDITOR_SOURCE_EXTRA_VALUE_ID_ datetime √ 2.16.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_FK_MODEL_SOURCE EDITOR_SOURCE_VALUE_ID_ ACT_FK_MODEL_SOURCE_EXTRA EDITOR_SOURCE_EXTRA_VALUE_ID_ ACT_FK_MODEL_DEPLOYMENT DEPLOYMENT_ID_ 2.17 流程定义数据表( act_re_procdef ) 2.17.1 简要描述 业务流程定义数据表。此表和ACT_RE_DEPLOYMENT是多对一的关系，即，一个部署的bar包里可能包含多个流程定义文件，每个流程定义文件都会有一条记录在ACT_REPROCDEF表内，每个流程定义的数据，都会对于ACT_GE_BYTEARRAY表内的一个资源文件和PNG图片文件。和ACT_GE_BYTEARRAY的关联是通过程序用ACT_GE_BYTEARRAY.NAME与ACT_RE_PROCDEF.NAME_完成的，在数据库表结构中没有体现 。 2.17.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ ID_ REV_ 乐观锁 int √ 乐观锁 CATEGORY_ 分类 nvarchar(255) √ 流程定义的Namespace就是类别 NAME_ 名称 nvarchar(255) √ 名称 KEY_ 定义的KEY nvarchar(255) 流程定义ID VERSION_ 版本 int 版本 DEPLOYMENT_ID_ 部署表ID nvarchar(64) √ 部署表ID RESOURCE_NAME_ bpmn文件名称 nvarchar(4000) √ 流程bpmn文件名称 DGRM_RESOURCE_NAME_ png图片名称 nvarchar(4000) √ 流程图片名称 DESCRIPTION_ 描述 nvarchar(4000) √ 描述 HAS_START_FORM_KEY_ 是否存在开始节点formKey tinyint √ start节点是否存在formKey 0否 1是 SUSPENSION_STATE_ 是否挂起 tinyint √ 1 激活 2挂起 2.17.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_UNIQ_PROCDEF KEY_, VERSION_ Unique 2.18 ( act_ru_event_subscr ) 2.18.1 简要描述暂无… 2.18.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ 事件ID nvarchar(64) √ 事件ID REV_ 版本 int √ 乐观锁Version EVENT_TYPE_ 事件类型 nvarchar(255) 事件类型 EVENT_NAME_ 事件名称 nvarchar(255) √ 事件名称 EXECUTION_ID_ 执行实例ID nvarchar(64) √ 执行实例ID PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID ACTIVITY_ID_ 活动实例ID nvarchar(64) √ 活动实例ID CONFIGURATION_ 配置 nvarchar(255) √ 配置 CREATED_ 是否创建 datetime 默认值 当前系统时间戳CURRENT_TIMESTAMP 2.18.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_IDX_EVENT_SUBSCR_CONFIG_ CONFIGURATION_ ACT_FK_EVENT_EXEC EXECUTION_ID_ 2.19 运行时流程执行实例表( act_ru_execution ) 2.19.1 简要描述 流程执行记录表。 2.19.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ ID_ REV_ 乐观锁 int √ 乐观锁 PROC_INST_ID_ 流程实例ID nvarchar(64) 流程实例ID BUSINESS_KEY_ 业务主键ID nvarchar(255) √ 业务主键ID PARENT_ID_ 父节点实例ID nvarchar(64) √ 父节点实例ID PROC_DEF_ID_ 流程定义ID nvarchar(64) √ 流程定义ID SUPER_EXEC_ SUPER_EXEC_ nvarchar(64) √ SUPER_EXEC_ ACT_ID_ 节点实例ID nvarchar(255) √ 节点实例ID即ACT_HI_ACTINST中ID IS_ACTIVE_ 是否存活 tinyint √ 是否存活 IS_CONCURRENT_ 是否并行 tinyint √ 是否为并行(true/false） IS_SCOPE_ IS_SCOPE_ tinyint √ IS_SCOPE_ IS_EVENT_SCOPE_ IS_EVENT_SCOPE_ tinyint √ IS_EVENT_SCOPE_ SUSPENSION_STATE_ 是否挂起 tinyint √ 挂起状态 1激活 2挂起 CACHED_ENT_STATE_ int √ 2.19.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_UNIQ_RU_BUS_KEY PROC_DEF_ID_, BUSINESS_KEY_ Unique ACT_IDX_EXEC_BUSKEY BUSINESS_KEY_ ACT_FK_EXE_PROCINST PROC_INST_ID_ ACT_FK_EXE_PARENT PARENT_ID_ ACT_FK_EXE_SUPER SUPER_EXEC_ 2.20 运行时流程人员表( act_ru_identitylink ) 2.20.1 简要描述 任务参与者数据表。主要存储当前节点参与者的信息。 2.20.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ ID_ REV_ 乐观锁 int √ 乐观锁 GROUP_ID_ 组ID nvarchar(64) √ 组ID TYPE_ 类型 nvarchar(255) √ 备注7 USER_ID_ 用户ID nvarchar(64) √ 用户ID TASK_ID_ 节点实例ID nvarchar(64) √ 节点实例ID PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID PROC_DEF_ID_ 流程定义ID nvarchar(255) √ 流程定义ID 2.20.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_IDX_IDENT_LNK_USER USER_ID_ Unique ACT_IDX_IDENT_LNK_GROUP GROUP_ID_ ACT_IDX_ATHRZ_PROCEDEF PROC_DEF_ID_ ACT_FK_TSKASS_TASK TASK_ID_ ACT_FK_IDL_PROCINST PROC_INST_ID_ 2.21 运行时定时任务数据表( act_ru_job ) 2.21.1 简要描述 运行时定时任务数据表。用到网上找的资料 字段描述.. 2.21.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ 标识 nvarchar(64) √ 标识 REV_ 版本 int √ 版本 TYPE_ 类型 nvarchar(255) 类型 LOCK_EXP_TIME_ 锁定释放时间 datetime √ 锁定释放时间 LOCK_OWNER_ 挂起者 nvarchar(255) √ 挂起者 EXCLUSIVE_ bit √ EXECUTION_ID_ 执行实例ID nvarchar(64) √ 执行实例ID PROCESS_INSTANCE_ID_ 流程实例ID nvarchar(64) √ 流程实例ID PROC_DEF_ID_ 流程定义ID nvarchar(64) √ 流程定义ID RETRIES_ int √ EXCEPTION_STACK_ID_ 异常信息ID nvarchar(64) √ 异常信息ID EXCEPTION_MSG_ 异常信息 nvarchar(4000) √ 异常信息 DUEDATE_ 到期时间 datetime √ 到期时间 REPEAT_ 重复 nvarchar(255) √ 重复 HANDLER_TYPE_ 处理类型 nvarchar(255) √ 处理类型 HANDLER_CFG_ nvarchar(4000) √ 标识 2.21.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_FK_JOB_EXCEPTION EXCEPTION_STACK_ID_ 2.22 运行时任务节点表( act_ru_task ) 2.22.1 简要描述 行时任务数据表。 2.22.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ ID_ REV_ 乐观锁 int √ 乐观锁 EXECUTION_ID_ 执行实例ID nvarchar(64) √ 执行实例ID PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID PROC_DEF_ID_ 流程定义ID nvarchar(64) √ 流程定义ID NAME_ 节点定义名称 nvarchar(255) √ 节点定义名称 PARENT_TASK_ID_ 父节点实例ID nvarchar(64) √ 父节点实例ID DESCRIPTION_ 节点定义描述 nvarchar(4000) √ 节点定义描述 TASK_DEF_KEY_ 节点定义的KEY nvarchar(255) √ 任务定义的ID OWNER_ 实际签收人 nvarchar(255) √ 拥有者（一般情况下为空，只有在委托时才有值） ASSIGNEE_ 签收人或委托人 nvarchar(255) √ 签收人或委托人 DELEGATION_ 委托类型 nvarchar(64) √ 备注8 PRIORITY_ 优先级别 int √ 优先级别，默认为：50 CREATE_TIME_ 创建时间 datetime √ 创建时间 DUE_DATE_ 过期时间 datetime √ 耗时 SUSPENSION_STATE_ 是否挂起 int √ 1代表激活 2代表挂起 2.22.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_IDX_TASK_CREATE CREATE_TIME_ ACT_FK_TASK_EXE EXECUTION_ID_ ACT_FK_TASK_PROCINST PROC_INST_ID_ ACT_FK_TASK_PROCDEF PROC_DEF_ID_ 2.23 运行时流程变量数据表( act_ru_variable ) 2.23.1 简要描述 运行时流程变量数据表。 2.23.2 表结构说明 字段名称 字段描述 数据类型 主键 为空 取值说明 ID_ ID_ nvarchar(64) √ 主键标识 REV_ 乐观锁 int √ 乐观锁 TYPE_ 类型 nvarchar(255) 备注9 NAME_ 名称 nvarchar(255) 变量名称 EXECUTION_ID_ 执行实例ID nvarchar(64) √ 执行的ID PROC_INST_ID_ 流程实例ID nvarchar(64) √ 流程实例ID TASK_ID_ 节点实例ID nvarchar(64) √ 节点实例ID(Local） BYTEARRAY_ID_ 字节表ID nvarchar(64) √ 字节表的ID（ACT_GE_BYTEARRAY） DOUBLE_ DOUBLE_ float √ 存储变量类型为Double LONG_ LONG_ numeric(19) √ 存储变量类型为long TEXT_ TEXT_ nvarchar(4000) √ &#39;存储变量值类型为String 如此处存储持久化对象时，值jpa对象的class TEXT2_ TEXT2_ nvarchar(4000) √ 此处存储的是JPA持久化对象时，才会有值。此值为对象ID 2.23.3 索引说明 索引名称 组成字段名称 索引类型 索引说明 PRIMARY ID_ Unique 主键唯一索引 ACT_IDX_VARIABLE_TASK_ID TASK_ID_ ACT_FK_VAR_EXE EXECUTION_ID_ ACT_FK_VAR_PROCINST PROC_INST_ID_ ACT_FK_VAR_BYTEARRAY BYTEARRAY_ID_ 备注： 备注1：行为类型。值为下列内容中的一种： AddUserLink、DeleteUserLink、AddGroupLink、DeleteGroupLink、AddComment、AddAttachment、DeleteAttachment 备注2：类型: FormProperty, //表单 VariableUpdate //参数 备注3、5、9：参数类型: jpa-entity、boolean、bytes、serializable(可序列化)、自定义type(根据你自身配置)、 CustomVariableType、date、double、integer、long、null、short、string 备注4、7：类型，主要分为以下几种： assignee 、 candidate 、 owner 、starter 、participant 备注6： 存储变量值类型为String，如此处存储持久化对象时，值jpa对象的class 备注8：委托类型，DelegationState分为两种：PENDING，RESOLVED。如无委托则为空","categories":[],"tags":[{"name":"Activiti","slug":"Activiti","permalink":"http://ilovejava.cn/tags/Activiti/"},{"name":"java","slug":"java","permalink":"http://ilovejava.cn/tags/java/"}]},{"title":"最最常用的git command","slug":"最常用的git command","date":"2016-01-10T05:36:43.000Z","updated":"2017-09-06T07:43:14.106Z","comments":true,"path":"posts/4a17a003/","link":"","permalink":"http://ilovejava.cn/posts/4a17a003/","excerpt":"不要浪费时间，直接开始正题吧。下面是碰到的具体情况对应的具体操作。","text":"不要浪费时间，直接开始正题吧。下面是碰到的具体情况对应的具体操作。 fork代码之后的同步fork他人的代码之后，自己做了修改，他人更新了，想要同步更新，同时也保存自己修改的内容，这个应用场景十分常见。在github、oschina、coding上都提供了web端可以直接同步的功能，但是在自己搭建的git服务上就不一定有了。 $ git remote -v origin https://github.com/yeqingyun/abc.git(fetch) origin https://github.com/yeqingyun/abc.git(push) $ git remote add upstream https://github.com/linus/abc.git $ git remote -v origin https://github.com/yeqingyun/abc.git(fetch) origin https://github.com/yeqingyun/abc.git(push) upstream https://github.com/linus/abc.git(fetch) upstream https://github.com/linus/abc.git(push) $ git fetch upstream $ git merge upstream/master 上面这个过程就将他人的代码同步到自己的代码中，下一次再同步时只需要执行 $ git fetch upstream $ git merge upstream/master 这种方法，也可以用于一些开发模式上，比如组长创建了项目a，三个组员分别fork了项目a，当他们在自己fork的项目中完成自己的模块后，组长可以去做如下操作来合并代码（其实这很类似于分支）。 $ git remote -v origin https://github.com/leader/a.git(fetch) origin https://github.com/leader/a.git(push) $ git remote add zs https://github.com/zs/abc.git $ git remote add ls https://github.com/ls/abc.git $ git remote add ls https://github.com/ww/abc.git $ git remote -v origin https://github.com/leader/a.git(fetch) origin https://github.com/leader/a.git(push) zs https://github.com/leader/a.git(fetch) zs https://github.com/leader/a.git(push) ls https://github.com/leader/a.git(fetch) ls https://github.com/leader/a.git(push) ww https://github.com/leader/a.git(fetch) ww https://github.com/leader/a.git(push) $ git fetch zs $ git merge zs/master $ git fetch ls $ git merge ls/master $ git fetch ww $ git merge ww/master 基于分支开发当项目升级到一个稳定的版本后，我们想要尝试加一些新功能（不确定的功能），又不愿意修改项目稳定版本的代码，这时就要利用分支来做开发了。我们新开一个分支，将新功能的代码提交到分支上，新功能开发完毕后，我们根据效果确定这个功能存在的必要性，再决定要不要把代码合并到主干上。在这里说明一下origin和branch的区别，origin是源，也就是代码的地址，而branch是分支，比如：github上每个项目有且只有一个唯一的标识自己的origin(例如：https://github.com/leader/a.git )，但每个项目能有许多的分支。git remote -v 查看到的就是代码的源，这里可以定义多个源，fetch和push的时候要指定目标源。git branch -a查看到的是本地和远程的分支。 $ git branch #查看分支 * master # * 标识当前分支 $ git branch test #创建分支 $ git branch #查看本地和远程分支 * master test $ git push origin test #推送分支到源（创建远程分支） $ git checkout test #切换到test分支 Switched to branch 'test' M .gitignore M pom.xml M src/main/java/com/gionee/uc/biz/model/App.java M src/main/resources/app.properties M src/main/webapp/WEB-INF/view/index.html M uc.iml $ git branch -a #查看本地和远程分支 master * test remotes/origin/master remotes/origin/test $ git branch --set-upstream-to=origin/test #将当前分支链接到远程分支 我们用(远程仓库名)/(分支名) 这样的形式表示远程分支，所以origin/master指向的是一个remote branch $ git push origin test #将test分支代码提交到远程分支上 $ git checkout master #切换到主干 $ git merge test #合并test到主干 $ git branch -r -d origin/test #删除分支 $ git push origin test #提交到远程分支 代码回滚这个基本是最常见的情景了 $ git log -5 #加上-p能对比提交内容差异 commit 4aeb48fec96cf62bda07fd27a5a267f8c58c77e9 (HEAD -&gt; master, origin/master) Author: yeqingyun Date: ... ... Signed-off-by: yeqingyun &lt;yeqy@gionee.com&gt; commit 96e95ce39b9f403c61f2f9b05c3e2b5ab04851d6 Author: yeqingyun Date: ... ... Signed-off-by: yeqingyun commit f6ffec9d6810af0b7f6709020f47fca55ee53ae1 Author: yeqingyun Date: Sat Aug 26 11:56:35 2017 +0800 Signed-off-by: yeqingyun $ git reset --hard 4aeb48 #只要输入指针的前6位 $ git push -f origin master #强制提交到远程主干 未完待续…","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://ilovejava.cn/tags/git/"}]},{"title":"用javascript开发一个俄罗斯方块","slug":"用javascript开发一个俄罗斯方块","date":"2016-01-09T05:36:43.000Z","updated":"2017-09-11T01:08:49.907Z","comments":true,"path":"posts/4a17a002/","link":"","permalink":"http://ilovejava.cn/posts/4a17a002/","excerpt":"开发游戏不仅能学习算法，也能锻炼人的思维逻辑，提高我们的编程能力，充实我们的问题思考能力和问题解决思路。俄罗斯方块想必大家都玩过，他的游戏逻辑并不复杂，今天我们就来用大家都熟悉的javascript开发一款俄罗斯方块，后续我会写出更多关于游戏开发的文章。","text":"开发游戏不仅能学习算法，也能锻炼人的思维逻辑，提高我们的编程能力，充实我们的问题思考能力和问题解决思路。俄罗斯方块想必大家都玩过，他的游戏逻辑并不复杂，今天我们就来用大家都熟悉的javascript开发一款俄罗斯方块，后续我会写出更多关于游戏开发的文章。 开发环境es5 + webpack 本文重点在讲解俄罗斯方块游戏的逻辑，如果不了解webpack的话可以去webpack官网查看相关文档，在这里我们不就不赘述了。代码中主要用到都是包括es5之前的语法以及api，因为这样可以让不了解es6和es7的同学也能看懂。 代码源码在我的github仓库中，大家可以看一看，代码重点在实现游戏逻辑，大家可以根据自己的需求进行优化。 在线演示俄罗斯方块 源码分析好了，开始解释代码吧，由于代码细节较多，在此我只说明一下重要的部分和总的思路。 index.html123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Square&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"local_game\" class=\"game\"&gt;&lt;/div&gt; &lt;div id=\"local_gameover\" class=\"gameover\"&gt;游戏结束&lt;/div&gt; &lt;div id=\"local_next\" class=\"next\"&gt;&lt;/div&gt; &lt;div class=\"info\"&gt; &lt;div&gt;已用时:&lt;span id=\"local_time\"&gt;0&lt;/span&gt;&lt;/div&gt; &lt;div&gt;已得分:&lt;span id=\"local_score\"&gt;0&lt;/span&gt;&lt;/div&gt; &lt;div class=\"btnWarp\"&gt;&lt;a href=\"javascript:void(0)\" id=\"local_start\" class=\"btn\"&gt;开始&lt;/a&gt;&lt;/div&gt; &lt;div class=\"btnWarp\"&gt;&lt;a href=\"javascript:void(0)\" id=\"local_pause\" class=\"btn\"&gt;暂停&lt;/a&gt;&lt;/div&gt; &lt;div class=\"btnWarp\"&gt;&lt;a href=\"javascript:void(0)\" id=\"local_stop\" class=\"btn\"&gt;结束&lt;/a&gt;&lt;/div&gt; &lt;div class=\"introduce\"&gt; 操作说明： &lt;p&gt;↑：变换 ↓：下落&lt;/p&gt; &lt;p&gt;←：左移 →：右移&lt;/p&gt; &lt;p&gt;空格：坠落&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这是主页的html代码，俄罗斯方块的所有操作都在这个页面完成，我们的代码也只有这一个html页面。local\\_game是显示我们游戏中操作方块的区域，loacl\\_gamover是显示游戏结束的隐藏区域，local_next是显示下一个方块的区域。之所以有一个前缀loacl是因为这个游戏后续将会加上与服务器的交互逻辑，这个将在以下篇文章提到，现在可以省略。接下来是业务的实现代码，我们的js分几个模块，下面将解释每个模块的作用 game.jsgame.js主要是控制方块的数据变化，dom节点的操作。 import _ from 'lodash'; import Square from \"./square.js\"; import SquareFactory from \"./squareFactory.js\"; export default function () { var gameData = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ] var dataClass = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ] var cur, next var gameContainers, nextContainers, timeDiv, gameoverDiv, scoreDiv var gameDivs = [], nextDivs = [] //初始化容器 var initDiv = function (data, container, divs) { for (var i = 0; i &lt; data.length; i++) { var gameDiv = [] for (var j = 0; j &lt; data[0].length; j++) { var newNode = document.createElement(\"div\") newNode.className = 'none' container.appendChild(newNode) gameDiv.push(newNode) } Array.prototype.push.call(divs, gameDiv) } } //刷新容器显示 var flushDiv = function (data, divs, classes) { for (var i = 0; i &lt; data.length; i++) { for (var j = 0; j &lt; data[0].length; j++) { if (data[i][j] == 0) { divs[i][j].className = 'none' } else { if (!classes[i][j]) classes[i][j] = 'A' divs[i][j].className = classes[i][j] } } } } //检测点是否合法 var checkPonit = function (pox, x, y) { if (pox.x + x &lt; 0) { return false } else if (pox.x + x &gt;= gameData.length) { return false } else if (pox.y + y &lt; 0) { return false } else if (pox.y + y &gt;= gameData[0].length) { return false } else if (gameData[pox.x + x][pox.y + y] == 1) { return false } return true } //监测数据是否合法 var valid = function (pos, data) { for (var i = 0; i &lt; data.length; i++) { for (var j = 0; j &lt; data[0].length; j++) { if (data[i][j] != 0) { if (!checkPonit(pos, i, j)) { return false; } } } } return true; } //设置数据 var setData = function () { for (var i = 0; i &lt; cur.data.length; i++) { for (var j = 0; j &lt; cur.data[0].length; j++) { if (checkPonit(cur.orgin, i, j)) { gameData[i + cur.orgin.x][j + cur.orgin.y] = cur.data[i][j] dataClass[i + cur.orgin.x][j + cur.orgin.y] = cur.class } } } } //清除数据 var clearData = function () { for (var i = 0; i &lt; cur.data.length; i++) { for (var j = 0; j &lt; cur.data[0].length; j++) { if (checkPonit(cur.orgin, i, j)) { gameData[cur.orgin.x + i][cur.orgin.y + j] = 0 dataClass[i + cur.orgin.x][j + cur.orgin.y] = 'none' } } } } var setTime = function (data) { if (timeDiv) { timeDiv.innerText = data } } var showGameOver = function () { gameoverDiv.style.display = 'block' } var clearGameOver = function () { gameoverDiv.style.display = 'none' } //初始化数据 var init = function (dom, type, dir) { next = SquareFactory.prototype.make(type, dir) gameContainers = dom.gameContainers nextContainers = dom.nextContainers timeDiv = dom.timeDiv gameoverDiv = dom.gameoverDiv scoreDiv = dom.scoreDiv initDiv(gameData, gameContainers, gameDivs) initDiv(next.data, nextContainers, nextDivs) flushDiv(next.data, nextDivs, next.classData) } //固定变色 var fixed = function () { for (var i = 0; i &lt; gameData.length; i++) { for (var j = 0; j &lt; gameData[0].length; j++) { if (checkPonit(cur.orgin, i, j)) { if (gameData[cur.orgin.x + i][cur.orgin.y + j] == 2) { gameData[cur.orgin.x + i][cur.orgin.y + j] = 1 } } } } flushDiv(gameData, gameDivs, dataClass) } var setScore = function (data) { if (scoreDiv) scoreDiv.innerText = data } var checkClear = function () { var lines = 0 function check(data) { return data == 1 } for (var i = gameData.length - 1; i &gt;= 0; i--) { var flag = gameData[i].every(check) if (flag) { lines++ for (var k = i; k &gt;= 1; k--) { gameData[k] = (gameData[k - 1]).slice(0) dataClass[k] = (dataClass[k - 1]).slice(0) } gameData[0] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] dataClass[0] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] i++ } } return lines } var checkGameOver = function () { if (gameData[0][3] == 1 || gameData[0][4] == 1 || gameData[0][2] == 1 || gameData[0][5] == 1) {//如果原点被占用 return true } if (!valid(next.orgin, next.data)) { return true } return false; } var nextSquare = function (type, dir) { cur = next setData() next = SquareFactory.prototype.make(type, dir) flushDiv(gameData, gameDivs, dataClass) initSquareClassData(next) flushDiv(next.data, nextDivs, next.classData) } var initSquareClassData = function (squ) { for (var i = 0; i &lt; squ.data.length; i++) { for (var j = 0; j &lt; squ.data[0].length; j++) { if (squ.data[i][j] != 0) { squ.classData[i][j] = squ.class } } } } //下移 var down = function () { if (cur.canDown(valid)) { clearData() cur.down() setData() flushDiv(gameData, gameDivs, dataClass) return true } return false } var left = function () { if (cur.canLeft(valid)) { clearData() cur.left() setData() flushDiv(gameData, gameDivs, dataClass) } } var right = function () { if (cur.canRight(valid)) { clearData() cur.right() setData() flushDiv(gameData, gameDivs, dataClass) } } var rotate = function () { if (cur.canRotate(valid)) { clearData() cur.rotate() setData() flushDiv(gameData, gameDivs, dataClass) } } var fall = function () { while (down()) { } } //销毁的方法 var destroyDiv = function () { for (var i = 0; i &lt; gameDivs.length; i++) { for (var j = 0; j &lt; gameDivs[0].length; j++) { gameContainers.removeChild(gameDivs[i][j]) } } for (var i = 0; i &lt; nextDivs.length; i++) { for (var j = 0; j &lt; nextDivs[0].length; j++) { nextContainers.removeChild(nextDivs[i][j]) } } } this.init = init this.down = down this.left = left this.right = right this.rotate = rotate this.fall = fall this.fixed = fixed this.nextSquare = nextSquare this.checkClear = checkClear this.checkGameOver = checkGameOver this.setTime = setTime this.showGameOver = showGameOver this.clearGameOver = clearGameOver this.setScore = setScore this.destroyDiv = destroyDiv } 首先我先来讲一下这个游戏的原理，玩过俄罗斯方块的都清楚他的规则，我们的方块都在一个容器内，不能超出边界。是的，这个容器就是index.html中的local_game，这个容器的大小是400px200px，我们定义一种小方块，每个大小为20px20px，这个容器就能容纳10列*20行也就是200个小方块，现在这个容器被我们的小方块填充满了，游戏中我们所有的小方块有三种状态，1.空的小方块，也就是游戏中那些空闲的区域（白的区域）。2.固定的小方块，已经固定不能移动的小方块。3.正在动的小方块，也就是我门游戏中正在操作的小方块。我们给这三中状态定义假设一个值，比如：第一种状态为0，第二中状态为1，第三种状态为2。我们将这样200个小方块存在一个二维数组中（这里我们称之为dom数组），再将这200个小方块存入一个二维数组中（这里我们称之为状态数组）。当我们按上下左右移动方块时，其实就是更改状态数组，然后在根据状态数组的值改变dom数组中小方块的样式，比如：状态0显示白色，状态1显示蓝色，状态2显示粉色。到这里游戏的基本原理大概就解释完了，看懂了的话，下面的代码实现也就很好理解了。没看明白的话，可能..是我没说清楚吧（Σ( ° △ °|||)︴），那你可以根据源码实现一遍，应该也会理解的。 接下来讲解源码，由上至下开始讲，顶部的模块引入和一些变量生命先将它们忽略，后面用到的时候会提到，先说一些比较重要的变量，gameData就是我们上面提到的保存方块状态的二维数组，gameDivs是我们保存200个小方块的二维数组，还记得游戏上边有显示下一个方块的区域吧，这个区域我们的游戏区域显示远离一致，只是他比较小，大小只有80px*80px，他其中的16个小方块保存在nexDivs二维数组中。接下来的讲解中我们将200个的这种方块称为小方块，游戏中左右上下操作的方块称为下落的方块，以免大家混淆。 //初始化容器 var initDiv = function (data, container, divs) { for (var i = 0; i &lt; data.length; i++) { var gameDiv = [] for (var j = 0; j &lt; data[0].length; j++) { var newNode = document.createElement(\"div\") newNode.className = 'none' container.appendChild(newNode) gameDiv.push(newNode) } Array.prototype.push.call(divs, gameDiv) } } //刷新容器显示 var flushDiv = function (data, divs, classes) { for (var i = 0; i &lt; data.length; i++) { for (var j = 0; j &lt; data[0].length; j++) { if (data[i][j] == 0) { divs[i][j].className = 'none' } else { if (!classes[i][j]) classes[i][j] = 'A' divs[i][j].className = classes[i][j] } } } } initDiv就是初始化容器的方法，他生成200个小方块设置样式为none并填充到容器中，因为容器和小方块的样式都是float:left,所以小方块能够顺序排列。flushDiv根据gameData中的数据变更小方块的样式。剩余的方法下面提及。接下里是下落的方块了。 square.jsvar Square = function () { this.data = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] this.classData = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] this.dir = 0 this.orgin = { x: 0, y: 0 } } Square.prototype.canDown = function (valid) { var testDown = { x: this.orgin.x + 1, y: this.orgin.y, } return valid(testDown, this.data) } Square.prototype.canLeft = function (valid) { var testLeft = { x: this.orgin.x, y: this.orgin.y - 1, } return valid(testLeft, this.data) } Square.prototype.canRight = function (valid) { var testRight = { x: this.orgin.x, y: this.orgin.y + 1, } return valid(testRight, this.data) } Square.prototype.canRotate = function (valid) { var d = (this.dir + 1) % 4 return valid(this.orgin, this.rotates[d]) } Square.prototype.down = function () { this.orgin.x += 1 } Square.prototype.left = function () { this.orgin.y -= 1 } Square.prototype.right = function () { this.orgin.y += 1 } Square.prototype.rotate = function (num) { if (!num) num = 1 this.dir = (this.dir + num) % 4 this.data = this.rotates[this.dir] } export default Square Square是所有下落方块的父类，data是描述方块形状的数组，此数组中只有状态3，因为他只表述运动中的方块，当方块固定下来后，这个方块回销毁，数据将存入game.js中的gameData，orgin是方块当前位置的原点，有了这个原点，移动方块时，只需要移动这个原点，这是一种很巧妙的思维方式，dataClass是保存运动中每个小方块样式的数组，每个下落的方块能翻转4次，dir是保存当前翻转形态的down,right,left是下落方块移动对应的方法，rotate是下落方块翻转的方法。对应的can方法是判断方块的位置是否能做对应的操作。 squareFactory.jsimport Square from \"./square.js\"; var prot = Object.create(Square.prototype) var Square1 = function () { Square.call(this) this.rotates = [ [ [0, 0, 0, 0], [2, 2, 2, 2], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0] ], [ [0, 0, 0, 0], [2, 2, 2, 2], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0] ] ] } Square1.prototype = prot var Square2 = function () { Square.call(this) this.rotates = [ [ [0, 2, 0, 0], [2, 2, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 2, 0, 0], [0, 2, 2, 0], [0, 2, 0, 0], [0, 0, 0, 0] ], [ [2, 2, 2, 0], [0, 2, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 2, 0, 0], [2, 2, 0, 0], [0, 2, 0, 0], [0, 0, 0, 0] ] ] } Square2.prototype = prot var Square3 = function () { Square.call(this) this.rotates = [ [ [0, 2, 0, 0], [0, 2, 2, 2], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 2, 2, 0], [0, 2, 0, 0], [0, 2, 0, 0], [0, 0, 0, 0] ], [ [2, 2, 2, 0], [0, 0, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 0, 2, 0], [0, 0, 2, 0], [0, 2, 2, 0], [0, 0, 0, 0] ] ] } Square3.prototype = prot var Square4 = function () { Square.call(this) this.rotates = [ [ [0, 0, 0, 0], [0, 2, 2, 0], [0, 2, 2, 0], [0, 0, 0, 0] ], [ [0, 0, 0, 0], [0, 2, 2, 0], [0, 2, 2, 0], [0, 0, 0, 0] ], [ [0, 0, 0, 0], [0, 2, 2, 0], [0, 2, 2, 0], [0, 0, 0, 0] ], [ [0, 0, 0, 0], [0, 2, 2, 0], [0, 2, 2, 0], [0, 0, 0, 0] ] ] } Square4.prototype = prot var Square5 = function () { Square.call(this) this.rotates = [ [ [2, 2, 0, 0], [0, 2, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 0, 2, 0], [0, 2, 2, 0], [0, 2, 0, 0], [0, 0, 0, 0] ], [ [2, 2, 0, 0], [0, 2, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 0, 2, 0], [0, 2, 2, 0], [0, 2, 0, 0], [0, 0, 0, 0] ] ] } Square5.prototype = prot var Square6 = function () { Square.call(this) this.rotates = [ [ [0, 0, 2, 0], [2, 2, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 2, 0], [0, 0, 0, 0] ], [ [2, 2, 2, 0], [2, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [2, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0], [0, 0, 0, 0] ] ] } Square6.prototype = prot var Square7 = function () { Square.call(this) this.rotates = [ [ [0, 2, 2, 0], [2, 2, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 2, 0, 0], [0, 2, 2, 0], [0, 0, 2, 0], [0, 0, 0, 0] ], [ [0, 2, 2, 0], [2, 2, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ], [ [0, 2, 0, 0], [0, 2, 2, 0], [0, 0, 2, 0], [0, 0, 0, 0] ] ] } Square7.prototype = prot var SquareFactory = function () { } SquareFactory.prototype.make = function (index, dir) { var classes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] var s index += 1 switch (index) { case 1: s = new Square1() break; case 2: s = new Square2() break; case 3: s = new Square3() break; case 4: s = new Square4() break; case 5: s = new Square5() break; case 6: s = new Square6() break; case 7: s = new Square7() break; } s.orgin.x = 0 s.orgin.y = 3 s.class = classes[Math.ceil(Math.random() * 9) - 1] s.rotate(dir) return s; } export default SquareFactory 看squareFactory这个名字大家都会明白这是个工厂模块，不明白工厂模式的请自行百度… 在squareFactory中定义了俄罗斯方块中基本的七种方块，并提供了生成方块的方法，这七中方块都继承自square，也就是它们都有移动的方法，不同于父模块，这些方块中的rotates定义了此方块翻转的四种形态。squareFactory的make方法根据参数生成方块，index参数代表要生成的方块，dir表示方块翻转的形态，这两个参数将由game模块传进来，当然这两个方块是随机数，因为每次的方块都是随机的。classes表示的是方块的样式，初始将会给方块也随机赋予一个颜色。 local.jsimport _ from 'lodash'; import Game from \"./game.js\"; export default function () { var game var timer var INTERVAL = 200 var hours var minute var seconds var score = 0 var timeCount = 0 var isStart = false; var isPause = false var bindKeyEvent = function () { document.onkeydown = function (e) { switch (e.keyCode) { case 38://up game.rotate() break case 39://right game.right() break case 37://left game.left() break case 40://down game.down() break case 32://space game.fall() break } } } var generateType = function () { return Math.ceil(Math.random() * 7) - 1 } var generateDir = function () { return Math.ceil(Math.random() * 4) - 1 } var addScore = function (data) { switch (data) { case 0: return 0 case 1: return 10 case 2: return 40 case 3: return 60 case 4: return 80 default: return 100 } } var gameOver = function () { clearInterval(timer) game.showGameOver() game.nextSquare(generateType(), generateDir()) document.onkeydown = null timer = null timeCount = 0 score = 0 isStart = true } var clearGameOver = function () { game.clearGameOver() game.destroyDiv() game.setScore(0) game.setTime(0) } var move = function (gamoverDiv) { if (!game.down()) {//如果不能下落 game.fixed()//固定 score += addScore(game.checkClear()) game.setScore(score)//消行 if (game.checkGameOver()) {//判断游戏是否结束 gameOver() } else { game.nextSquare(generateType(), generateDir())//生成下一个方块 } } } var addTime = function () { timeCount++; if (timeCount % 5 == 0) { seconds = timeCount / 5 var showTime; if (seconds &gt;= 3600) { var tmp = seconds % 3600 var tmpMinute = Math.floor(tmp / 60) showTime = Math.floor(seconds / 3600) + \"小时\" + tmpMinute + '分' + tmp % 60 + '秒' } else if (seconds &gt;= 60) { showTime = Math.floor(seconds / 60) + \"分\" + seconds % 60 + '秒' } else { showTime = seconds + '秒' } game.setTime(showTime) } } var start = function () { if (!timer) { if(isStart) clearGameOver() game = new Game() var doms = { gameContainers: document.getElementById(\"local_game\"), nextContainers: document.getElementById(\"local_next\"), timeDiv: document.getElementById(\"local_time\"), gameoverDiv: document.getElementById(\"local_gameover\"), scoreDiv: document.getElementById(\"local_score\") } game.init(doms, generateType(), generateDir()) game.nextSquare(generateType(), generateDir()) bindKeyEvent() timer = setInterval(function () { move() addTime() }, INTERVAL) } } var pause = function (e) { if (!isPause &amp;&amp; timer) { isPause = true clearInterval(timer) this.innerText = '继续' this.onclick = continue_ document.onkeydown = null } } var continue_ = function () { if (isPause) { isPause = false timer = setInterval(function () { move() addTime() }, INTERVAL) this.innerText = '暂停' this.onclick = pause bindKeyEvent() } } var stop = function () { isStart = false clearInterval(timer) document.onkeydown = null timer = null game.destroyDiv() game.clearGameOver() game.setScore(0) game.setTime(0) timeCount = 0 score = 0 } var init = function () { //绑定开始按钮事件 document.getElementById(\"local_start\").onclick = start //绑定暂停按钮事件 document.getElementById(\"local_pause\").onclick = pause //绑定结束按钮事件 document.getElementById(\"local_stop\").onclick = stop } this.init = init } local模块主要是开始，暂停，继续，结束按钮事件和上下左右空格键盘输入事件以及判断游戏结束的。这块不是我们的重点环节，注释都有，大家自行食用吧。 总体描述我们的游戏代码其实就是主页加载local,loacl绑定键盘和按钮事件，事件中调用game,game再调用squareFactory生成下落方块，当我们输入操作时，再通过Square中对应的方法修改下落方块的data数组和orgin原点，game再通过原点和data修改自己的gameData，接着再通过gameData数组来刷新gameDivs和nextDivs中小方块的样式。由于代码细节较多，如方块消行，加分，判断点位置合法性，判断游戏结束等等，我也不可能一一列出啦，所以这些细节大家如果感兴趣的话可以到源码中去查看。怎么样，明白了吗？有什么问题请下方留言。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://ilovejava.cn/tags/javascript/"},{"name":"游戏","slug":"游戏","permalink":"http://ilovejava.cn/tags/游戏/"},{"name":"算法","slug":"算法","permalink":"http://ilovejava.cn/tags/算法/"}]}]}